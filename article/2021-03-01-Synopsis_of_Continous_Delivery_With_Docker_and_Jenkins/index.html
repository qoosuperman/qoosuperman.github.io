<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Anthony&#39;s Blog, about Ruby / Rails / Devops">
    <meta name="keyword" content="">
    <meta property="og:image" content="undefined">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <title>
        
          Synopsis of Continous Delivery With Docker and Jenkins - Anthony Chao | Blog
        
    </title>

    <link rel="canonical" href="https://qoosuperman.github.io/article/2021-03-01-Synopsis_of_Continous_Delivery_With_Docker_and_Jenkins/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<link rel="alternate" href="/atom.xml" title="Anthony Chao" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://images.unsplash.com/photo-1605447302541-bd14aa1417ab?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Devops" title="Devops">Devops</a>
                            
                              <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                            
                              <a class="tag" href="/tags/#Continuous Delivery" title="Continuous Delivery">Continuous Delivery</a>
                            
                              <a class="tag" href="/tags/#Jenkins" title="Jenkins">Jenkins</a>
                            
                        </div>
                        <h1>Synopsis of Continous Delivery With Docker and Jenkins</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Anthony Chao on
                            2021-03-01
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Anthony Chao</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p><a href="#intro">Intro</a><br>
<a href="#configuring-jenkins">Configuring Jenkins</a><br>
<a href="#continous-integration-pipeline">Continous Integration Pipeline</a><br>
<a href="#configuration-management-with-ansible">Configuration Management with Ansible</a><br>
<a href="#continous-delivery-pipeline">Continous Delivery pipeline</a><br>
<a href="#clustering-with-docker-swarm">Clustering with Docker Swarm</a><br>
<a href="#advanced-continous-delivery">Advanced continous delivery</a></p>
<hr>
<p>以下內容幾乎都來自 Continuous Delivery with Docker and Jenkins 這本書</p>
<p>本文整理這本書的概要作為之後參考</p>
<h1>Intro</h1>
<h2>What is Continous delivery</h2>
<p>所謂的 Continous delivery(CD), 就是要把所有在產品上做的變化，包括新 feature / infra 上的變動 / bugfix 都用安全而且持續有效率的方式交付到使用者手上</p>
<p>在以前的情況，如果今天要在信件系統裡面加上一個功能，開發組花了一個禮拜之後開發交給 QA team，完成之後給 operation team，可能又要花幾天甚至幾個禮拜時間才能 release，如果使用 continous delivery 就可以讓使用者在開發完成之後很快可以使用到新功能</p>
<p>傳統的 delivery process:</p>
<ul>
<li>development<br>
開發有時候包括市場分析的部分，通常會用敏捷開發的方式，demo session 則是為了得到消費者的第一手回饋</li>
<li>QA<br>
這個階段通常稱為 UAT(User Acceptance Testing)，其中 non-functional testing 是指效能, security 等等測試</li>
<li>operations<br>
通常是最短的一個階段，負責 release 新機能到 production 並 monitor<br>
<img src="https://i.imgur.com/f6qaaVH.png" alt=""></li>
</ul>
<p>其中一個最能闡述 continous delivery 的優點是 flicker 跟 yahoo，當時 yahoo 併購了 flicker，在併購之前他們的 deliver 策略是不同的，yahoo 很少 release，每次 release 都有複雜的測試跟 operation 過程，而 flicker 則是一天會有好幾次的部署，每次的變動都很少</p>
<p>最後調查出來，整個 yahoo 公司裡面 downtime 最少的就是 flicker 的 service，因此慢慢把這個策略用到其他產品上<br>
<img src="https://i.imgur.com/Mi96qrn.png" alt=""></p>
<p>這也說明了： 如果 code 變動越少，這個 release 越安全，而這個步驟越經常執行就越安全</p>
<h2>auto deployment pipeline</h2>
<p>為了讓 release 自動化達到 continous delivery 的境界，我們先看一下如果把它自動化之後 pipeline 應該要長怎樣<br>
<img src="https://i.imgur.com/H5BRhu3.png" alt=""></p>
<h3>Continuous Integration</h3>
<p>Continuous Integration 的階段提供檢查的第一手資訊給 developer，會跑 develper 寫的 unit tests 藉此檢查 code quality</p>
<h3>Automated acceptance testing</h3>
<p>automated acceptance testing 的階段應該是由顧客跟 QA 一起準備的測試項目，用來取代傳統 UAT，它代表著這個產品是不是準備好 release 了</p>
<p>這個測試是為了讓傳統上使用者預期的行為寫到測試裡面，讓他跟著開發的內容一起被測試，而不是開發完一段時間之後再做測試，但這部分通常也是最困難的，因為要把原本的預期行為寫成 code 的測試</p>
<p>這裡常常造成困惑的地方是，到底哪些部分要給 QA team 測試，哪些測試要被程式 cover，可以用 Agile testing matrix 跟 testing pyramid 來澄清</p>
<h4>The Agile testing matrix</h4>
<p><img src="https://i.imgur.com/j1PwN24.png" alt=""></p>
<ul>
<li>
<p>Acceptance Testing (automated)<br>
這就是取代傳統 UAT 的部分，會寫成 user stories 或者一些範例，由 QA 跟使用者的觀點決定這個軟體應該如何運作，比較接近以 “user” 的觀點寫的</p>
</li>
<li>
<p>Unit Testing (automated)<br>
developer 自己寫的 unit tests，比較接近以 “code” 的觀點寫的</p>
</li>
<li>
<p>Exploratory Testing (manual)<br>
由 QA team 操作，試圖破壞這個系統，或想想有什麼可以改良的地方，在自動化的架構下，QA 不應該執行重複的測試項目</p>
</li>
<li>
<p>Non-functional Testing (automated)<br>
有關一些 performance, scalability, security 等等的測試</p>
</li>
</ul>
<p>至於為什麼沒有看到 integration test 呢？首先我們要知道 integration test 會因為內容的不同，意義不同，如果是很小型的 service，那 integration test 可能就等於 unit test 跟 acceptance test cover 的範圍，如果是許多 module 之間的測試，那可能就會寫在一些 unit test 跟 UAT test 之間的地方，雖然寫法上接近 UAT test，但是是以 code 的觀點寫的，因為他可能會需要 mock 很多 module 的 service 等等</p>
<h4>The testing pyramid</h4>
<p>在這個金字塔裡面，越往上的測試會越慢，而且產生這些測試的成本越高，這也是為何 acceptance test 通常無法 100% cover，因此他們通常需要 feature 導向，然後選擇特定場景測試，否則可能會花太多資源在寫測試上</p>
<p>相較之下，寫 unit test 的成本是最少最快的，所以我們應該盡量 100% cover 這一塊</p>
<h3>Configuration management</h3>
<p>這個部分就包括了所有部署需要的事情，像是安裝需要的套件，這裡會需要一些 configuration management tools，像是 Ansible, Chef 等等</p>
<p>另外還有一部分是 application monitoring，這通常需要串流 log 跟相關的 metric 到一個 dashboard 上面</p>
<h2>organizational prerequisites</h2>
<p>如果要導入 continous delivery 需要有一些先決條件，就像要導入 Agile process 的話，組織上也需要有一些調整，比方說你需要有 product owner, stakeholders，整個組織也需要知道在 sprint 之中不能有其他需求上的改變</p>
<p>如果要導入 continous delivery，可以從 DevOps culture, a client in the process, and business decisions 這三點來看</p>
<h3>DevOps culture</h3>
<p>在以前，軟體由一個 team 開發，可能是同一個人開發，測試，部署到 production，但隨著系統變大，組織變大，慢慢把這些工作分工，大家各司其職增進效率，獨立出 QA team, operation team，而每個工程師負責專業的一塊東西</p>
<p>這樣的壞處就是溝通需要額外的資源，組織分的越開，溝通上越困難，這樣的文化不利於 Continuous Delivery process，我們需要導入 DevOps culture</p>
<p>DevOps culture 的概念上像是回到最初，某個人或者某個 team 負責所有的工作，而可以轉換成使用這種 Devops model 的關鍵就在於自動化</p>
<p>一個 devops team 不一定都是 developer，有種常見的配置是 4 個 developer， 1 個 QA， 1 個 operation，但這些人需要非常緊密合作才能消除溝通資源的消耗<br>
<img src="https://i.imgur.com/qK8HRT4.png" alt=""></p>
<hr>
<h1>configuring Jenkins</h1>
<p>Jenkins 是一個 open source 的自動化 server code，用 Java 寫的，目前最流行的 CI/CI 工具</p>
<h2>Jenkins architecture</h2>
<p>Jenlins 大部分的使用方式都是拆成 master-slave 的架構，主要負責管控的為 Jenkins master，做事情的為 Jenkins slave 或者稱 Jenkins agent</p>
<p>可以在設定完第一個 slave 之後，把 master 的 node 變成 offline，不然有一些 build 還是會在 master 上面執行</p>
<p>master 的工作主要為</p>
<ol>
<li>接收 build 的 trigger</li>
<li>送 nitofications</li>
<li>處理 Jenkins client 上面的請求(像是網頁的)</li>
<li>整合 slaves</li>
</ol>
<h2>Configuring agents</h2>
<p>master 跟 slave 溝通的方式有幾種：</p>
<ol>
<li>SSH: master 本身已經有 ssh-client built-on，所以只有 agent 身上有 SSHD server 就可以辦到，這是一個方便且穩定的方法</li>
<li>Java Web Start: Java application 在 agent 上面開起來，然後在 master 跟 slave 之間建立 TCP 連線，如果 agent 在防火牆裡面不容易透過 ssh 連線的話有時候會用這個方法</li>
<li>Windows service: 在 master 身上註冊一個 windows server，不建議使用</li>
</ol>
<p>agent 的設置上又可以分成好幾種：</p>
<ul>
<li>Permanent agents</li>
<li>Permanent Docker agents</li>
<li>Jenkins Swarm agents</li>
<li>Dynamically provisioned Docker agents</li>
</ul>
<h3>- Permanent agents</h3>
<p>這種 agent 的缺點就是固定的 slave 數量，有幾個 slave 就要照顧他們不要讓他們輕易掛掉</p>
<p>通常這種範例會有下圖的情況：<br>
需要 build 哪種東西，指定專門的 slave node 處理<br>
<img src="https://i.imgur.com/yhL35KY.png" alt=""></p>
<p>如果要做一個 slave node 可以參考下面做法：<br>
首先要把這個 node 準備好 =&gt; 一台機器跟環境設定<br>
因為 Jenkins master 會在 slave node 上面安裝 client program，我們需要安裝跟 master 同樣的 Java version 在 slave node 上面</p>
<p>如果 master 是透過 ssh 連到 slave 就需要產生 master 這邊的 ssh key</p>
<p>接著就是在 master 這邊的 web UI 上面做設定</p>
<p>Manage Jenkins =&gt; Manage Nodes =&gt; New Node =&gt; Permanent Agent</p>
<p>之後有些比較需要注意的選項：</p>
<p>Launch method 在這個範例中使用 ssh 連線</p>
<p>然後 Remote Root directory 是指在 slave node 這邊選擇一個資料夾給 master 存放東西，所以 master 使用的 ssh user 需要對這個資料夾有 read / write access</p>
<p>接著會跳出一個 popup window 要輸入一些 credential，這個範例中我們選擇 <code>SSH Username with private keys</code>，然後填入自己的 ssh username 跟 ssh private key，這樣就設定完成</p>
<p>參考資料：<br>
<a href="https://chathura-siriwardhana.medium.com/step-by-step-guide-to-add-jenkins-slave-nodes-f2e756c8849e" target="_blank" rel="noopener">https://chathura-siriwardhana.medium.com/step-by-step-guide-to-add-jenkins-slave-nodes-f2e756c8849e</a></p>
<h3>- Permanent Docker agents</h3>
<p>這種的 slave node 基本上每一台都會是一樣的，但每一台 slave node 上面需要裝好 Docker engine，至於環境的不同會寫在 build 裡面</p>
<p>在 pipeline 撰寫上的唯一不同就是需要指定 Docker image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">     agent &#123;</span><br><span class="line">          docker &#123;</span><br><span class="line">               image &apos;openjdk:8-jdk-alpine&apos;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在這種情況下，每一個 slave agent 都長得一樣，只是在不同 script 下面我們會指定不同的 image，但如果不用 image 的話，通常每種不同專長的 slave node 有不同 label，會指定不同 script 使用不同 label 的 slave node<br>
<img src="https://i.imgur.com/mBUd0kJ.png" alt=""></p>
<h3>Jenkins Swarm agents</h3>
<p>Jenkins Swarm 可以讓我們動態增加 slave，不用每一台都是做設定</p>
<p>乍看之下這個方法可能沒什麼用，我們只是把設定 agent 的工作從 master 搬到 slave node 來做，但還是需要手動做，但在後面的 Clustering with Docker Awarm 的部分比較能感受它的價值</p>
<p>要做到這個需要裝個 pugin: <code>Self-Organizing Swarm Plug-in Modules</code>，接著在每一台可以做為 slave node 的機器上面安裝 Jenkins Swarm slave application，可以透過 <code>swarm-client.jar</code> 這個 application 安裝，指令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -jar swarm-client.jar -master &lt;jenkins_master_url&gt; -username</span><br><span class="line">   &lt;jenkins_master_user&gt; -password &lt;jenkins_master_password&gt; -name jenkins-</span><br><span class="line">   swarm-slave-1</span><br></pre></td></tr></table></figure>
<h3>Dynamically provisioned Docker agents</h3>
<p>還有另一個選項是，當有 build 產生的時候，就動態的產生一個 slave agent 處理</p>
<p>要做到這個方法需要在 master 這邊裝上 <code>Docker plugin</code></p>
<p>Manage Jenkins =&gt; Configure System =&gt; Cloud =&gt; Add a new cloud =&gt; Docker<br>
接著會填入一些資訊:</p>
<p>Docker URL: 要填入 Docker host machine 的 address，這也是之後那些 slave node(container) 會在哪裡跑起來</p>
<p>如果要讓 Docker host 跑在跟 master 同樣的一台機器上，Docker daemon 需要 listen to docker0 network interface<br>
<img src="https://i.imgur.com/2LA17Xl.png" alt=""></p>
<p>接著要填入一些 Docker template 的參數<br>
<img src="https://i.imgur.com/Uq7QGIL.png" alt=""><br>
Docker image: 目前最多人用的 image 是這個 <code>evarga/jenkins-slave</code></p>
<p>credentails: 對於 上面這個 image 來說 credentials 是 username: jenkins password: jenkins</p>
<p>Instance capacity: 設定最多可以多少個 agent(container) 同時跑起來</p>
<p><img src="https://i.imgur.com/cM2NhNh.png" alt=""><br>
跑的流程如上圖所示：</p>
<ol>
<li>當有個 Jenkins job，master 就會在 Docker host 跑起一個用 jenkins-slave image 做的 container，這個 container 實際上就是裝好 SSHD server 的 ubuntu container</li>
<li>master 會主動把這個新做出來的 slave node 加到自己的 agent list 裡面</li>
<li>agent 用 ssh 去執行這個 build 任務</li>
<li>完成之後 master 會把 container 停掉並移除 container</li>
</ol>
<h1>Continous Integration Pipeline</h1>
<p>Jenkins pipeline 主要由兩個元件組成： stages 跟 steps</p>
<p>step 是指單一個操作，而 stage 則是邏輯上用來區別不同 steps 的東西，我們可以以 stage 為單位觀察 Jenkins pipeline 目前的進度<br>
<img src="https://i.imgur.com/oWTo3sh.png" alt=""></p>
<h2>Pipeline syntax</h2>
<ul>
<li>
<p>pipeline: 每一個 piepline 會定義在 <code>pipeline</code> 這個 block 裡面，其中 <code>stage</code> 跟 <code>steps</code> 都在寫這個 pipeline 裡面最主要執行的步驟</p>
</li>
<li>
<p>steps: <code>steps</code> 是 pipeline 最基本的組成單位，有一些基本的 operations 可以使用, 其他 syntax可以參考這個頁面:<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="noopener">https://jenkins.io/doc/pipeline/steps/</a></p>
<ul>
<li>sh: 執行 shell command</li>
<li>custom: Jenkins 還有內建很多 operaions, 比方說 echo，但大部分都是把 sh 的 command 再包一層起來</li>
<li>script: 會執行 groovy-based code</li>
</ul>
</li>
</ul>
<p>step 的其他 syntax(主要是 basic steps):<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="noopener">https://jenkins.io/doc/pipeline/steps/</a></p>
<ul>
<li>
<p>post: <code>post</code> 這個 block 會定義一個或多個 steps，這些 steps 會在符合條件的情況下(比方說 always 或者成功 / 失敗)，在 build 結束之後執行，常常是送通知等等事情，除了 always 還有這些選項：<code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code></p>
</li>
<li>
<p>agent: <code>agent</code> 則是指定這個工作給誰執行，可以用 <code>label</code> 來指令 slave node 或者 <code>docker</code> 指定 container</p>
</li>
<li>
<p>triggers: <code>triggers</code> 這個設定定義了怎麼自動化 trigger pipeline， <code>cron</code> 是設定固定時間排程，<code>pollscm</code> 則是檢查 repo 是不是有更新</p>
</li>
<li>
<p>options: <code>options</code> 定義一些選項，比方說 <code>timeout</code> 可以指定 pipeline 最長執行時間，<code>retry</code> 可以指定失敗的話重新執行的次數</p>
</li>
<li>
<p>environment: <code>environment</code> 定義 env var 的 key value pair</p>
</li>
<li>
<p>parameters: <code>parameters</code> 定義 user 應該丟進來的 parameters</p>
</li>
<li>
<p>when: <code>when</code> 某個條件，決定這個 stage 是不是應該執行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">     agent any</span><br><span class="line">     triggers &#123; cron(&apos;* * * * *&apos;) &#125;</span><br><span class="line">     options &#123; timeout(time: 5) &#125;</span><br><span class="line">     parameters &#123;</span><br><span class="line">             booleanParam(name: &apos;DEBUG_BUILD&apos;, defaultValue: true,</span><br><span class="line">             description: &apos;Is it the debug build?&apos;)</span><br><span class="line">     &#125;</span><br><span class="line">     stages &#123;</span><br><span class="line">          stage(&apos;Example&apos;) &#123;</span><br><span class="line">               environment &#123; NAME = &apos;Rafal&apos; &#125;</span><br><span class="line">               when &#123; expression &#123; return params.DEBUG_BUILD &#125; &#125;</span><br><span class="line">               steps &#123;</span><br><span class="line">                    echo &quot;Hello from $NAME&quot;</span><br><span class="line">                    script &#123;</span><br><span class="line">                         def browsers = [&apos;chrome&apos;, &apos;firefox&apos;]</span><br><span class="line">                         for (int i = 0; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                              echo &quot;Testing the $&#123;browsers[i]&#125; browser.&quot;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     post &#123; always &#123; echo &apos;I will always say Hello again!&apos; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>Triggers and notification</h2>
<p>如果只是單純把 pipeline 寫出來，我們還是要手動去啟動，所以要真的自動化也要讓這些 pipeline 被自動 trigger</p>
<p>所有的 trigger 我們可以分成三個部分</p>
<h3>- External</h3>
<p>這個方法主要有一個外在因素(notifier)去叫 Jenkins 開始執行 job，有可能是另一個 pipeline 或者 Github<br>
<img src="https://i.imgur.com/ok1yFgR.png" alt=""></p>
<h3>- Polling SCM</h3>
<p>這個方法比較不直覺，Jenkins 會固定時間 call github 然後檢查是不是這個 repo 有任何新的 push，有才去開始 job<br>
<img src="https://i.imgur.com/bza3FsK.png" alt=""></p>
<p>有時候可能會用到這種方法：</p>
<ol>
<li>Jenkins 如果架在防火牆內</li>
<li>常常有 commit 但是每次 build 都需要花很長一段時間，這時候如果每次 commit 都去 build，可能會造成 server overload</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">triggers &#123;</span><br><span class="line">     pollSCM(&apos;* * * * *&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>- Scheduled build</h3>
<p>表示 Jenkins 單純照著時間排成進行，不管有沒有其他外在因素<br>
<img src="https://i.imgur.com/29IYbaN.png" alt=""></p>
<h3>Automated Acceptance Testing</h3>
<p><img src="https://i.imgur.com/yFmNp2c.png" alt=""></p>
<p>範例中 pipeline 整個流程像是下面這樣，把 code 推上去 Github(source code repository) 之後，自動 trigger build binary file 儲存到 Artifact repository，用這些 build 好的檔案執行 Acceptance testing, Non-functional testing，都通過的話就 release 到環境</p>
<p>而如果我們是直接用 docker 跑的話，這裡的 artifact 可以是 Docker registry(ex. Docker Hub)</p>
<p>其中 Jenkins 的運作可以看下圖<br>
<img src="https://i.imgur.com/6eivOq3.png" alt=""></p>
<h1>Configuration Management with Ansible</h1>
<p>Configuration Management 包括了 Application configuration 跟 Infrastructure configuration</p>
<p>Application configuration 通常包含了一些 flags 或者 propertiy files，像是 database address, logging level 之類的</p>
<p>Infrastructure configuration 則是定義在每台 server 上面要裝好哪些 dependencies，並且指定 applications 之間應該怎麼編排<br>
<img src="https://i.imgur.com/DFvzOGe.png" alt=""><br>
通常會有一個 configuration management tool 去讀取我們寫好的 configuration file 然後把環境準備好</p>
<p>書裡面還寫了很多怎麼使用 Ansible 的部分, 之後會再整理成另一篇</p>
<h1>Continous Delivery pipeline</h1>
<h2>Nonfunctional testing</h2>
<p>對於 non-functional testing 到底要測試什麼？像是對於使用者來說，一秒就大概是使用者覺得服務使用上沒有被打斷的極限，大於一秒就很有可能讓使用者不繼續使用你的服務</p>
<p>執行 non-functional testing 的步驟應該經歷下面這些過程：</p>
<ol>
<li>列出所有 non-functional test 清單</li>
<li>決定哪些應該是不需要的，不需要的原因可能很多，像是這個測試的製作跟維護成本太高，或者本身系統是設計給單一 instance 使用，或者這個系統很小，目前使用簡單的 performance test 就已經夠了等等</li>
<li>把他們拆成兩大類：
<ul>
<li>Continuous Delivery: 可以加到 pipeline 的</li>
<li>Analysis: 不適合加到 piepline 的，可能是執行時間太長等等原因</li>
</ul>
</li>
<li>對於應該放到 piepline 這些 test 加上對應的 stage，把他們放進去</li>
<li>對於不應該放到 pipeline 的這些 test 準備自動化腳本，討論什麼時候該執行他們</li>
</ol>
<p>以下列舉一些常見的 non-functional test</p>
<h3>Performance testing</h3>
<p>這是在測試系統的反應跟穩定度，最簡單的就是送個 request 然後測量 round-trip time(RTT)</p>
<p>有時候可以使用專門的框架來測試時間，像是 Java 的 JMeter</p>
<h3>Load testing</h3>
<p>load testing 是用來測試當有很多 concurrent requests 的時候，系統會有怎樣的行為，通常是測試平均的 request-response time，畢竟只有一個單獨 request 的時候，系統可能很快，但在 1000 個 request 同時打的情況下就不一定了</p>
<h3>stress testing</h3>
<p>stress testing 又稱為 capacity testing 或者 throughput testing，這是用來測試同一時間有多少個 concurrent user 可以使用 service，雖然跟 load testing 很像但他們不一樣</p>
<p>在 load testing 裡面我們固定 concurrent 數量，然後測試 response time 超過某設定值就讓這個測試失敗</p>
<p>而在 stress testing 裡面，固定 response time，慢慢增加 thorughput 來找到臨界值</p>
<p>因此在 CD pipeline 裡面不適合加上 stress test，因為他需要比較長時間的嘗試，而是應該準備一個 test script，當作分別的 Jenkins pipeline 來執行，只有在需要測試的時候去 trigger，比方說我們覺得某段 code 可能會影響 performance 的時候可以測試看看</p>
<h3>Scalability testing</h3>
<p>這在測試當我們使用不同 server 數量的時候，response time 如何反應，最棒的表現會是線性，像是當有一台 server 的時候，如果有 100 個 request，每個 request 平均是 500ms，如果有兩台應該要可以 serve 200 個 request，平均 response time 還是 500ms，但實際上很難做到，因為要在不同 server 間 keep data consistent</p>
<p>這種測試應該提供圖表比較好參考機器的數量跟 concurrent user 之間的關係</p>
<p>這個測試也不適合放在 CD pipeline 裡面</p>
<h3>Endurance testing</h3>
<p>也稱為 longevity test, 把系統跑起來很長一段時間看看 performance 是不是有 drop，可以偵測有沒有 memory leak issue 跟 stability issue</p>
<p>因為這要跑很長一段時間，也不適合放在 CD piepline 裡面</p>
<h3>Security testing</h3>
<p>Securirty test 又有分不同面向，如果是一些 authentication / authorization 應該直接放在 accesptance test phase, 但有一些像是 SQL injection 的防護，則應該歸類在 non-functional tests</p>
<p>但這些測試應該放在 CD pipeline 中</p>
<h3>Maintainability testing</h3>
<p>這是在測試整個系統是不是好維護，檢查有沒有一些 anti pattern，然後有一些 design pattern 應該被使用讓這個系統比較好維護，測試 test coverage 也算是其中一環</p>
<h3>Recovery testing</h3>
<p>測試萬一系統 crash 之後，多快可以 recover，有些公司甚至故意讓 production 環境 randomly fail，比較有名的像是 Netflix Chaos Monkey tool，會隨意關掉 production 的 instance，讓工程師寫出對於系統 fail 更彈性的 code</p>
<h2>Application versioning</h2>
<p>在 versioning 方面通常有下面幾種策略：</p>
<ul>
<li>segment versioning: 最主要的一種，通常是以 <code>x.y.z</code> 這樣的方式表現
<ul>
<li>x: major version, 當他增加的時候表示不需向後相容</li>
<li>y: minor version, 當他增加的時候表示需要向後相容</li>
<li>z: build number, 通常表示需要前後相容</li>
</ul>
</li>
<li>timestamp: 直接用時間日期表示版本號，在 coding 上比較方便，因為不用人工下版本號</li>
<li>hash: 用隨機亂數表示版本號，缺點是沒辦法從這些亂數判斷版本誰先誰後</li>
<li>mixed: 組合前面幾種方式</li>
</ul>
<h2>Complete continuous delivery pipeline</h2>
<p>目前完整的 delivery process 就如同下面 Jenkins file 所寫的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">  pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">      pollSCM(&apos;* * * * *&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">      stage(&quot;Compile&quot;) &#123; steps &#123; sh &quot;./gradlew compileJava&quot; &#125; &#125;</span><br><span class="line">      stage(&quot;Unit test&quot;) &#123; steps &#123; sh &quot;./gradlew test&quot; &#125; &#125;</span><br><span class="line">      stage(&quot;Code coverage&quot;) &#123; steps &#123;</span><br><span class="line">        sh &quot;./gradlew jacocoTestReport&quot;</span><br><span class="line">        publishHTML (target: [</span><br><span class="line">                reportDir: &apos;build/reports/jacoco/test/html&apos;,</span><br><span class="line">                reportFiles: &apos;index.html&apos;,</span><br><span class="line">                reportName: &quot;JaCoCo Report&quot; ])</span><br><span class="line">         sh &quot;./gradlew jacocoTestCoverageVerification&quot;</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Static code analysis&quot;) &#123; steps &#123;</span><br><span class="line">        sh &quot;./gradlew checkstyleMain&quot;</span><br><span class="line">        publishHTML (target: [</span><br><span class="line">                reportDir: &apos;build/reports/checkstyle/&apos;,</span><br><span class="line">               reportFiles: &apos;main.html&apos;,</span><br><span class="line">               reportName: &quot;Checkstyle Report&quot; ])</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Build&quot;) &#123; steps &#123; sh &quot;./gradlew build&quot; &#125; &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Docker build&quot;) &#123; steps &#123;</span><br><span class="line">         sh &quot;docker build -t leszko/calculator:$&#123;BUILD_TIMESTAMP&#125; .&quot;</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Docker push&quot;) &#123; steps &#123;</span><br><span class="line">         sh &quot;docker push leszko/calculator:$&#123;BUILD_TIMESTAMP&#125;&quot;</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">     stage(&quot;Deploy to staging&quot;) &#123; steps &#123;</span><br><span class="line">         sh &quot;ansible-playbook playbook.yml -i inventory/staging&quot;</span><br><span class="line">         sleep 60</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Acceptance test&quot;) &#123; steps &#123; sh &quot;./acceptance_test.sh&quot; &#125; &#125;</span><br><span class="line">      # 在 staging 執行 UAT test，都正常才會往下執行部屬到 production</span><br><span class="line"></span><br><span class="line">      // Performance test stages</span><br><span class="line"></span><br><span class="line">      stage(&quot;Release&quot;) &#123; steps &#123;</span><br><span class="line">         sh &quot;ansible-playbook playbook.yml -i inventory/production&quot;</span><br><span class="line">         sleep 60</span><br><span class="line">      &#125;  &#125;</span><br><span class="line"></span><br><span class="line">      stage(&quot;Smoke test&quot;) &#123; steps &#123; sh &quot;./smoke_test.sh&quot; &#125; &#125;</span><br><span class="line">      # 這一步只是檢查正確的版本有沒有被部署到 production 上</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Clustering with Docker Swarm</h1>
<p>目前我們在 ansible script 裡面 hard code instance ip 資訊，代表我們沒辦法隨心所欲 scale instance，如果不想要加一個 instance 就改變我們的 code，也就是不想去管這些 instance ip 的話，我們應該善用 server clustering 的機制</p>
<h2>Server Clustering</h2>
<p>server cluster 是一群互相連線的電腦，他們像是存在在同一個系統一樣一起工作，彼此之間通常是透過區網連線，連線速度必須快到就算他們是分散式系統，這樣的影響也要很小</p>
<p>使用者會透過一個 manager 去連到這個 cluster，這個 manager 需要去編排這些 process，像是 task dispatching, service discovery, load balancing, worker failure detection 等等<br>
<img src="https://i.imgur.com/PmG9ZdI.png" alt=""></p>
<h2>Docker Swarm</h2>
<p>Docker 這個團隊自己出了一套 clustering 系統叫做 Docker swarm</p>
<p>他會把多個 Docker hosts 轉變成一個 cluster, 稱之為 swarm，這些 host 可能分別扮演 manager 或者 worker 的角色，每個 swarm 裡面至少一個 manager</p>
<ul>
<li>
<p>node: 主機的別稱, 也可以稱作 host, node 又分成 manager 跟 worker 兩種不同角色</p>
</li>
<li>
<p>Task: scheduling unit 的最小單位，會定義 container 的 image 還有一些需要給 container 執行的 command</p>
</li>
<li>
<p>service: 在 node 上面執行的 tasks，比方說這個 service 可能包含三個不同的 tasks 並且每個 task 裡面有一個 container</p>
</li>
<li>
<p>Replica: 每個 node 上面的每一個 container 都是一個 replica<br>
<img src="https://i.imgur.com/hcidaoB.png" alt=""></p>
</li>
</ul>
<p>雖然這張圖上面每個 node 都只有跑一個 container，但也有可能所有 container 跑在同一個 Docker host 上面，這要靠 manager 去編排<br>
<img src="https://i.imgur.com/VWDglLK.png" alt=""></p>
<h1>Advanced continous delivery</h1>
<h2>Pipeline</h2>
<h3>Parallelizing pipelines</h3>
<p>對很多 time-consuming 的 pipeline step 來說，像是 performance test，最好是平行執行節省時間</p>
<p>在 Jenkins 平行執行的方式主要又有以下兩種</p>
<ul>
<li>Parallel steps: 在同樣的 agent 上面平行執行，因為所有相關檔案會放在同一個機器上，所有執行上相對簡單，只是 resource 就會被限制在這一個 agent 裡面</li>
<li>Parallel stages: 每一個 stage 會放在不同的 agent 上執行，也因此如果這個 stage 要用到另一個 stage 的某個檔案的話，要注意 file transfer(需要用到 Jenkinsfile 的 stash 關鍵字)</li>
</ul>
<p>以下面的 parallel step 舉例</p>
<p>Stage1 的 step <code>one</code> 跟 step <code>two</code> 是平行執行的，而且 stage2 會等到前面兩個 step 都執行完才開始執行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">   agent any</span><br><span class="line">   stages &#123;</span><br><span class="line">       stage(&apos;Stage 1&apos;) &#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">               parallel (</span><br><span class="line">                       one: &#123; echo &quot;parallel step 1&quot; &#125;, # 平行執行 step1</span><br><span class="line">                       two: &#123; echo &quot;parallel step 2&quot; &#125;  # 平行執行 step2</span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       stage(&apos;Stage 2&apos;) &#123;    # stage2 等到 stage1 執行完成才會開始</span><br><span class="line">           steps &#123;</span><br><span class="line">               echo &quot;run after both parallel steps are completed&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>Reusing pipeline components</h3>
<p>很多時候，大部分的 code 會是重複的，只是要修改部分的參數，又或者是在很多不同的 pipeline 裡面要用到同一段 code，我們分別可以用 parameterized build / shared libraries 來解決</p>
<ul>
<li>parameterized build</li>
</ul>
<p>下面這個例子吃一個外來的參數 <code>Environment</code></p>
<p>這種做法在只有小部分的參數需要替換的時候，可以幫我們省下寫很多重複的 code，但不宜過度使用，不然 pipeline 可能變得難以理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">   agent any</span><br><span class="line">   parameters &#123;</span><br><span class="line">       string(name: &apos;Environment&apos;, defaultValue: &apos;dev&apos;, description: &apos;Which</span><br><span class="line">         environment (dev, qa, prod)?&apos;)</span><br><span class="line">   &#125;</span><br><span class="line">   stages &#123;</span><br><span class="line">       stage(&apos;Environment check&apos;) &#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">               echo &quot;Current environment: $&#123;params.Environment&#125;&quot;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/2CnASAk.png" alt=""></p>
<ul>
<li>shared libraries<br>
如果我們很多個 Jenkins file 要用到同一段 code，我們可以單獨把這些重複的 code 變成一個 repo 然後 include 他們</li>
</ul>
<p>比方說我們建一個 Github repo, 這個 repo 只有一個檔案(慣例上我們把方法當作檔名，放在 <code>vars</code> 這個資料夾內)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vars/sayHello.groovy  # 等等這個檔名 sayHello 就會變成可以使用的 step</span><br><span class="line">/**</span><br><span class="line">* Hello world step.</span><br><span class="line">*/</span><br><span class="line">def call(String name) &#123;</span><br><span class="line">  echo &quot;Hello $name!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著在我們的 Jenkins 去 include 這個 library</p>
<p>Manage Jenkins =&gt; Configure System =&gt; Global Pipeline Libraries<br>
<img src="https://i.imgur.com/UPSKJVB.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&quot;Hello stage&quot;) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">            sayHello &apos;Rafal&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剛剛使用的檔案 <code>sayHello</code> 可以直接當我們的 pipeline step</p>
<p>更多shared library例子：<br>
<a href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/" target="_blank" rel="noopener">https://www.jenkins.io/doc/book/pipeline/shared-libraries/</a></p>
<h2>CD Best practices</h2>
<p>以下列出本書作者對於 CD best practice 建議</p>
<ol>
<li>own process within the team<br>
Development and Operations from the beginning to the end, from receiving requirements to monitoring the production:</li>
</ol>
<ul>
<li>確保自己會 pipeline 的每一個 stage, 包括怎麽 build software, 怎麼 release</li>
<li>避免有一個 pipeline 專家，大家都應該要會</li>
<li>找到一個可以分享 pipeline 狀況的方法，常用的方法是一個大螢幕放在公用空間</li>
<li>如果 developer / QS / operation 是不同專家，至少要在同一個 agile team, 根據專長分 team 常常造成沒有人對產品負責</li>
</ul>
<ol start="2">
<li>
<p>automate everything!<br>
如果你正在做某件事情第二遍，嘗試把他自動化</p>
</li>
<li>
<p>version everything!<br>
包括 source code, build scripts, 測試, configuration management, pipelines, documents 等等，最好一切都要做 version 控制</p>
</li>
<li>
<p>use business language for acceptance tests!<br>
用商業語言來寫測試可以改善雙向溝通</p>
</li>
<li>
<p>be ready to roll back!</p>
</li>
</ol>
<blockquote>
<p>You don’t need more QAs, you need a faster rollback</p>
</blockquote>
<p>為了 rollback 的加速，可以考慮藍綠部署 / 金絲雀部署</p>
<ol start="6">
<li>
<p>don’t underestimate the impact of people<br>
就算是 QA 跟 IT operations 都是 Devops team 的一部分，一定會需要他們的專業，如果他們在做一些重複性的事情，應該要提供 training 把這些事轉為自動化</p>
</li>
<li>
<p>build in traceability!<br>
number of requests, the latency, the load of production servers, 這些都應該做 monitor, 包括任何你覺得可以幫助你分析目前產品的資訊</p>
</li>
<li>
<p>integrate often!</p>
</li>
</ol>
<blockquote>
<p>Continuous is more often than you think.</p>
</blockquote>
<p>作者建議多使用 Trunk-base 開發模式 / feature toggle</p>
<ol start="9">
<li>
<p>build binaries only once!<br>
對於 compile language 來說，應該只 build 一次，並在不同環境使用同一份 binary file, 除了節省時間 / 資源之外也可以避免不同環境之間的差異</p>
</li>
<li>
<p>release often!<br>
作者建議甚至可以每一次的 commit 都做一次 release，避免一年做一次 release 然後事前可能要為這次的 release 做長達三個月的準備</p>
</li>
</ol>
<blockquote>
<p>If it hurts, do it more often</p>
</blockquote>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/2021-03-18-Dynamic_port_setting_on_ECS/" data-toggle="tooltip" data-placement="top" title="Dynamic Port Setting on ECS">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/2021-02-25-rails_caching_basic_intro/" data-toggle="tooltip" data-placement="top" title="Rails Cache Basic Introduction">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Intro</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">What is Continous delivery</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">auto deployment pipeline</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">Continuous Integration</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">Automated acceptance testing</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.2.1.</span> <span class="toc-nav-text">The Agile testing matrix</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.2.2.</span> <span class="toc-nav-text">The testing pyramid</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">Configuration management</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">organizational prerequisites</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">DevOps culture</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">configuring Jenkins</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Jenkins architecture</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Configuring agents</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">- Permanent agents</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">- Permanent Docker agents</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">Jenkins Swarm agents</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">2.2.4.</span> <span class="toc-nav-text">Dynamically provisioned Docker agents</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Continous Integration Pipeline</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">Pipeline syntax</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">Triggers and notification</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">- External</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">- Polling SCM</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.3.</span> <span class="toc-nav-text">- Scheduled build</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">3.2.4.</span> <span class="toc-nav-text">Automated Acceptance Testing</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">Configuration Management with Ansible</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">Continous Delivery pipeline</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">Nonfunctional testing</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text">Performance testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text">Load testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text">stress testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.4.</span> <span class="toc-nav-text">Scalability testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.5.</span> <span class="toc-nav-text">Endurance testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.6.</span> <span class="toc-nav-text">Security testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.7.</span> <span class="toc-nav-text">Maintainability testing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.1.8.</span> <span class="toc-nav-text">Recovery testing</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">Application versioning</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">Complete continuous delivery pipeline</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Clustering with Docker Swarm</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">Server Clustering</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">Docker Swarm</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">Advanced continous delivery</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">Pipeline</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.1.1.</span> <span class="toc-nav-text">Parallelizing pipelines</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.1.2.</span> <span class="toc-nav-text">Reusing pipeline components</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">CD Best practices</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Devops" title="Devops">Devops</a>
                        
                          <a class="tag" href="/tags/#Docker" title="Docker">Docker</a>
                        
                          <a class="tag" href="/tags/#Continuous Delivery" title="Continuous Delivery">Continuous Delivery</a>
                        
                          <a class="tag" href="/tags/#Jenkins" title="Jenkins">Jenkins</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://riverye.com" target="_blank">小菜</a></li>
                    
                        <li><a href="https://chaichai.site" target="_blank">柴柴</a></li>
                    
                        <li><a href="https://louiswuyj.site" target="_blank">Louis</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/qoosuperman">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Anthony Chao 2026 
                    <br>
                    
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://qoosuperman.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-153986590-1';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://qoosuperman.github.io/img/icon_wechat.png" alt="prevent_hack" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
