<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anthony Chao</title>
  <icon>https://www.gravatar.com/avatar/c763eb253e8ae08f88afeab608afdb84</icon>
  <subtitle>Pseudo Worker not allowed</subtitle>
  <link href="https://qoosuperman.github.io/atom.xml" rel="self"/>
  
  <link href="https://qoosuperman.github.io/"/>
  <updated>2025-05-04T14:24:27.536Z</updated>
  <id>https://qoosuperman.github.io/</id>
  
  <author>
    <name>Anthony Chao</name>
    <email>qoosuperman@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人生四千個禮拜 書摘</title>
    <link href="https://qoosuperman.github.io/article/2025-05-04-%E4%BA%BA%E7%94%9F%E5%9B%9B%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C%20%E6%9B%B8%E6%91%98/"/>
    <id>https://qoosuperman.github.io/article/2025-05-04-%E4%BA%BA%E7%94%9F%E5%9B%9B%E5%8D%83%E5%80%8B%E7%A6%AE%E6%8B%9C%20%E6%9B%B8%E6%91%98/</id>
    <published>2025-05-04T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.536Z</updated>
    
    <content type="html"><![CDATA[<p>最近在休息或者出遊時，喜歡看點閒書沈澱一下心情。感謝友人借我 《人生四千個禮拜》 這本好書，有改變了我對於時間焦慮還有真正放鬆休息的一些看法。</p><p>標題中的「四千個禮拜」是在說人類平均壽命大約只有四千個禮拜，書中的大意提醒我們：生命是有限的，但與其追求掌控時間，不如學會與時間和平共處。</p><p>想要記錄一下一些重要的概念，除了跟大家分享之外，也用來提醒以後的自己。</p><h2>注意力不是資源，是我們的生活本身</h2><p>社群媒體讓人習慣被打斷，將注意力消耗在不重要的事上。</p><p>注意力是有限的，但說注意力是一種「資源」不足以說明他在生活中扮演多核心的角色。其他資源像是金錢 / 電力都是讓生活更便利的事物，就算少了也能活下去。但注意力「就是」生活，我們生活著的體驗，就是付出注意力的每件事的總和，因此要更有意識的花用。</p><h2>真正重視的事，今天就開始</h2><p>我們總期待有一天能有空做「真正重要的事」，但唯一確保會做的方法就是「今天就做一點」，哪怕只是幾分鐘，也代表你把注意力投資在真正重要的事上。</p><h2>越重要的事越想逃避</h2><p>人們常發現，越重要的事做起來反而越容易感到無聊或想逃避。那是因為我們正在直視自己的極限。這並沒有簡單解法，只能接受那份痛苦、投入更多專注力，像苦行僧一樣透過注意力緩解修行中的痛苦。</p><h2>有意義的休息：做點沒「效率」的事吧！</h2><p>現代人就連休息時都想「善用時間」，反而壓力更大。作者建議若要為休息帶來滿足感，你的嗜好或許甚至應該讓人感到有點尷尬，就像搖滾巨星花時間做自己不擅長的鐵道模型，因為自己不擅長，自然就暫時沒有 「善用時間」的焦慮，允許自己不為生產力而活，才是深層放鬆。</p><h2>時間的價值</h2><p>最後也分享書中我很喜歡的一句話：「時間的價值並非單純來自你個人用有多少時間，而是能否與你最愛的人共度」</p>]]></content>
    
    
    <summary type="html">人生四千個禮拜 書摘</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Retrospect And Prospect of 2025</title>
    <link href="https://qoosuperman.github.io/article/2024-01-14-Retrospect_And_Prospect_of_2025/"/>
    <id>https://qoosuperman.github.io/article/2024-01-14-Retrospect_And_Prospect_of_2025/</id>
    <published>2025-02-02T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>2024 年的前三季投入了大量時間在學習上，但或許正因如此，到了年底感覺有些彈性疲乏。這段經歷讓我深刻體會到，學會如何放鬆與整理內心同樣至關重要，這也是一門值得持續練習的課題。</p><p>接下來，簡單回顧一下 2024 年玩過的遊戲、達成的目標與值得紀錄的事情，並展望 2025 年的目標！</p><h2>2024 目標回顧</h2><h3>✅ 已完成目標</h3><ul><li><strong>培養學習熱忱</strong></li><li><strong>上木工的線上課程，並自己做一個傢俱</strong></li><li><strong>跟朋友維繫感情</strong></li></ul><h3>⏳ 未完成目標與原因</h3><ul><li><strong>一座百岳</strong><ul><li>地震太多，後半年仍有大小餘震。</li></ul></li><li><strong>培養運動習慣</strong><ul><li>前半年滿規律的，有游泳 / 上桌球課，但後來時間常常喬不攏而取消。</li></ul></li></ul><h2>🎮 今年遊玩的遊戲</h2><ul><li><strong>Final Fantasy VII Rebirth</strong></li><li><strong>零之軌跡</strong></li><li><strong>碧之軌跡</strong></li><li><strong>歧路旅人 2</strong></li><li><strong>九日</strong></li><li><strong>小丑牌</strong></li><li><strong>P 的謊言</strong></li></ul><p>今年玩過的遊戲當中，最喜歡的絕對是 <strong>《九日》</strong>，不得不讚嘆赤燭團隊的實力。他們目前推出的三款遊戲（《返校》 / 《還願》 / 《九日》）類型各不相同，但品質卻始終超越我的預期。</p><p>《九日》這款遊戲的戰鬥難度相當高，但相比《隻狼》，普通難度下的體感雖然仍具挑戰性，卻不至於帶來過強的挫敗感，反而讓人打起來十分過癮。此外，美術風格也是一大亮點 —— 在玩這款遊戲之前，我完全沒想過「道教 + Cyberpunk」會是一個可行的藝術風格，但遊戲中卻將這個組合展現得相當出色，並且又融入一些台灣元素。例如：</p><ul><li><strong>攻擊時的符咒系統</strong></li><li><strong>廟宇造型的建築設計</strong></li><li><strong>主角身上的道士服</strong></li></ul><p>第二喜歡的遊戲是 <strong>《P 的謊言》</strong>。雖然這款遊戲屬於<strong>類魂</strong>類型，但與《黑暗靈魂》或《隻狼》相比，整體的「惡意程度」大幅降低，這讓戰鬥體驗變得更流暢、爽快，不會讓人感到過度沮喪或挫折。</p><p>今年突然想懷舊一波，回去玩了 <strong>《零之軌跡》</strong> 和 <strong>《碧之軌跡》</strong> 這兩款老遊戲。剛開始滿滿都是懷舊感，確實讓人回憶起當年的遊戲時光。但玩到後來，不可避免地感受到一些「作業感」，因此短時間內應該不會繼續挑戰其他軌跡系列作品。</p><p>當初玩 <strong>《Final Fantasy VII Reunion》</strong> 時覺得非常好玩，但這次《Rebirth》加入了開放世界元素後，反而讓遊戲變得有些乏味，作業感變得相當明顯，導致遊玩過程不如預期地讓人投入。</p><h2>Conference</h2><p>今年參加了多場技術研討會，包括 DDD Conf、Ruby Conf 和 Hello World Dev Conf，此外也參加了一些技術交流活動，如 Generative AI 小聚和 Ruby Jam。</p><p>其中和同事一起參加 DDD conf，這讓我們能夠在會後立即交流討論，我覺得這樣帶來的學習效果是更顯著更即時的。</p><p>參加研討會多年，除了專注於聆聽講者的分享，我也發現與講者交流往往能獲得更多關於技術思維和實踐經驗的「心法」。不過，這對於身為 I 人的我來說是一大挑戰。希望未來自己能更大方地與講者交流，進一步拓展視野與人脈。</p><h2>學習相關</h2><p>今年主要學習的幾個主題：</p><ul><li>LangChain</li><li>DDD</li><li>Hotwire</li></ul><p>此外，我也幫朋友使用 WordPress 架設網站，並成功獲得 AA 等級的無障礙標章，這個過程讓我對 wordpress 有點了解，並知道了網站無障礙設計要考慮哪些因素</p><p>另一件讓我收穫良多的事情是跟同事一起組織讀書會，共同研讀 《Shape Up》 這本書。透過彼此的觀點分享與討論，我們不僅更了解彼此的想法，也能集思廣益，探索是否有方法可以優化現有的工作流程。即使最後發現這本書對我們的流程改善幫助有限，它仍然讓我們拓展了視野，並且成功促進了團隊的凝聚力與共識。</p><h2>值得紀錄的事情</h2><h3>學習木工</h3><p>學習木工絕對是今年投入最多時間、金錢和精力的一件事。從採買設備、準備工作室到磨刀，每個環節都相當耗費心力，但當我全神貫注投入其中時，能有效讓自己放空、消除煩惱，成為一種很好的調劑。</p><p>今年總共完成了 五件作品：鍋墊 / 托盤 / 矮凳 / 盒子 / 圓凳。每當作品完工時，滿滿的成就感更是無可取代！</p><h3>北海道旅遊</h3><p>今年的北海道之旅超棒！</p><ul><li>解鎖了第一次自駕的成就</li><li>第一次吃到炸牛排</li><li>清晨慢跑小樽運河，氛圍超 chill</li><li>品嚐北海道各地區的清酒</li><li>首次在日本爬郊山（藻岩山）</li><li>吃到老婆讚不絕口的迴轉壽司（TORITON）</li><li>第一次清酒喝到飽</li><li>洞爺湖水上煙火</li></ul><h3>其他</h3><ul><li>跟同事參加大港開唱</li><li>首次在 Ruby Jam 分享</li><li>上桌球課</li><li>參加《尋人啟事》演唱會</li><li>開車找住在山上的同事(Amo)</li><li>嘗試去咖啡廳（小灣）上班</li><li>新竹城市尋寶</li><li>高雄兩日遊</li><li>桌游清倉</li><li>跟同事玩劇本殺</li></ul><h2>2025 的目標</h2><ul><li>學著好好休息</li><li>培養運動習慣</li><li>繼續學習木工</li><li>練習當個爸爸</li></ul>]]></content>
    
    
    <summary type="html">Retrospect And Prospect of 2025</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>CircleCI Dynamic Config 介紹</title>
    <link href="https://qoosuperman.github.io/article/2024-12-17-CircleCI%20Dynamic%20Config%20%E4%BB%8B%E7%B4%B9/"/>
    <id>https://qoosuperman.github.io/article/2024-12-17-CircleCI%20Dynamic%20Config%20%E4%BB%8B%E7%B4%B9/</id>
    <published>2024-12-17T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.536Z</updated>
    
    <content type="html"><![CDATA[<p>最近因為工作需要，接觸了 CircleCI 的 <a href="https://circleci.com/docs/dynamic-config/" target="_blank" rel="noopener">Dynamic Config</a> 功能，使用之後覺得這個功能既強大又非常的有幫助，所以想來好好介紹一下。</p><p>以下會介紹一下這個功能，透過範例來說明他解決了什麼問題，以及我的使用案例跟心得。</p><h2>什麼是 Dynamic Config？</h2><p>簡單來說，Dynamic Config 是透過 <code>.circleci/config.yml</code> 定義的流程（workflows），動態決定接下來的流程，官方稱一開始的設定為 “setup configuration”，而接下來動態產生的設定為 “dynamic configuration”。</p><p>下一個流程的配置（dynamic configuration）可以是事先準備好的檔案內容，也可以是動態產生的設定。</p><p>實際上在一開始的流程中，會產生一個 <code>CIRCLE_CONTINUATION_KEY</code> 的環境變數，用它來打 <a href="https://circleci.com/docs/api/v2/index.html#tag/Pipeline/operation/listPipelines" target="_blank" rel="noopener">Continue a pipeline API</a> 來繼續下個流程（<a href="https://circleci.com/docs/dynamic-config/#how-dynamic-config-works" target="_blank" rel="noopener">ref</a>），但實際上使用的時候並不用知道這些，只需要知道如何使用他們提供的 orb 來完成這些事情即可。</p><h2>Dynamic Config 功能解決了什麼問題？</h2><p>在一般的 CircleCI 使用情境中，我們會在 <code>.circleci/config.yml</code> 中定義自動化流程，在 <a href="https://circleci.com/docs/workflows/#workflows-configuration-examples" target="_blank" rel="noopener">官方文件</a> 中可以看到很多範例</p><p>然而，當流程變得複雜時，就會遇到以下問題：</p><ul><li>流程過於複雜，難以理解。</li><li>所有組件（commands、jobs、workflows）都必須寫在同一個檔案中，導致文件難以閱讀和維護。</li><li>當前後端同時存在於一個專案中，無法根據變動的檔案動態選擇要執行的流程。</li></ul><p>而這些問題都可以透過 Dynamic Config 來解決，以下是一些來自 <a href="https://circleci.com/docs/using-dynamic-configuration/" target="_blank" rel="noopener">官方文件</a> 的範例。</p><h2>範例</h2><h3>動態產生下個流程的 YAML 配置檔案</h3><p>在這個範例中，setup configuration 裡面定義的流程會產生 <code>generated_config.yml</code> 這個檔案，而下個流程就會根據這個檔案來執行，這表示 Dynamic Config 支援憑空生成的配置檔案作為後續的 workflow 設定。</p><p>這裡使用到的 <code>circleci/continuation@1</code> 是一個 Dynamic Config 常常會用到的重要 orb（相當於 CircleCI 中的「套件」），透過它可以方便地串接下一個設定檔。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .circleci/config.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"><span class="attr">setup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">orbs:</span></span><br><span class="line">  <span class="attr">continuation:</span> <span class="string">circleci/continuation@1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">setup:</span></span><br><span class="line">    <span class="attr">executor:</span> <span class="string">continuation/default</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">checkout</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="comment"># run command to run script to generate YAML config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">./generate-config</span> <span class="string">&gt;</span> <span class="string">generated_config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">continuation/continue:</span></span><br><span class="line">          <span class="attr">configuration_path:</span> <span class="string">generated_config.yml</span> <span class="comment"># use newly generated config to continue the pipeline</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">my-setup-workflow:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">setup</span></span><br></pre></td></tr></table></figure><h3>根據檔案變動決定要執行的流程</h3><p>在這個範例中，<code>.circleci/config.yml</code> 中定義的 workflow 執行完成後，產生一些參數，根據 <code>.circleci/continue_config.yml</code> 啟動並傳遞參數給下一個 workflow。</p><p>這裡使用了 <a href="https://circleci.com/developer/orbs/orb/circleci/path-filtering" target="_blank" rel="noopener">circleci/path-filtering</a> orb，它能根據檔案變動設置 pipeline 參數，進而動態選擇執行的 workflow。</p><p>例如：</p><ul><li>若 <code>service1/</code> 目錄內的檔案變動，會將 <code>run-build-service-1-job</code> 參數設為 true，執行 <code>service-1</code> workflow。</li><li>若 <code>service2/</code> 目錄內的檔案變動，則執行 <code>service-2</code> workflow。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .circleci/config.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"><span class="attr">setup:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">orbs:</span></span><br><span class="line">  <span class="attr">path-filtering:</span> <span class="string">circleci/path-filtering@1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">always-run:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path-filtering/filter:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">check-updated-files</span></span><br><span class="line">          <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">service1/.*</span> <span class="string">run-build-service-1-job</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">service2/.*</span> <span class="string">run-build-service-2-job</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">base-revision:</span> <span class="string">main</span></span><br><span class="line">          <span class="attr">config-path:</span> <span class="string">.circleci/continue_config.yml</span> <span class="comment"># this is the default so not actually required but left in to illustrate options</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .circleci/continue_config.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"><span class="attr">orbs:</span></span><br><span class="line">  <span class="attr">maven:</span> <span class="string">circleci/maven@1.2.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">run-build-service-1-job:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">run-build-service-2-job:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">service-1:</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">&lt;&lt;</span> <span class="string">pipeline.parameters.run-build-service-1-job</span> <span class="string">&gt;&gt;</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">maven/test:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">build-service-1</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">'install -DskipTests'</span></span><br><span class="line">          <span class="attr">app_src_directory:</span> <span class="string">'service1'</span></span><br><span class="line">  <span class="attr">service-2:</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">&lt;&lt;</span> <span class="string">pipeline.parameters.run-build-service-2-job</span> <span class="string">&gt;&gt;</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">maven/test:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">build-service-2</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">'install -DskipTests'</span></span><br><span class="line">          <span class="attr">app_src_directory:</span> <span class="string">'service2'</span></span><br><span class="line">  <span class="attr">run-integration-tests:</span></span><br><span class="line">    <span class="attr">when:</span></span><br><span class="line">      <span class="attr">or:</span> <span class="string">[&lt;&lt;</span> <span class="string">pipeline.parameters.run-build-service-1-job</span> <span class="string">&gt;&gt;,</span> <span class="string">&lt;&lt;</span> <span class="string">pipeline.parameters.run-build-service-2-job</span> <span class="string">&gt;&gt;]</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">maven/test:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">run-integration-tests</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">'-X verify'</span></span><br><span class="line">          <span class="attr">app_src_directory:</span> <span class="string">'tests'</span></span><br></pre></td></tr></table></figure><h3>根據變動檔案動態產生配置檔案，並把零組件配置在不同檔案</h3><p>這個專案中，我們有兩個目錄，<code>src</code> 和 <code>docs</code>，分別存放程式碼和文件，而他們也有各自定義的流程（workflows）分別定義在 <code>code-config.yml</code> 和 <code>docs-config.yml</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .circleci</span><br><span class="line">│   ├── code-config.yml</span><br><span class="line">│   ├── config.yml</span><br><span class="line">│   ├── docs-config.yml</span><br><span class="line">│   ├── no-updates.yml</span><br><span class="line">│   ├── shared</span><br><span class="line">│   │   └── jobs</span><br><span class="line">│   │       ├── any-change.yml</span><br><span class="line">│   │       ├── lint.yml</span><br><span class="line">│   │       └── test.yml</span><br><span class="line">│   │   └── workflows</span><br><span class="line">│   │       ├── run-on-any-change.yml</span><br><span class="line">|   |       └── @shared.yml</span><br><span class="line">├── README.md</span><br><span class="line">├── docs</span><br><span class="line">│   └── my-docs.txt</span><br><span class="line">└── src</span><br><span class="line">    └── my-code.txt</span><br></pre></td></tr></table></figure><p>在這個範例中，透過 <code>circleci config pack</code> 指令，可以把原本分散的 workflows / jobs 重新組合成 <code>.circleci/shared-config.yml</code>。(前面有提到正常情況下，我們會把 workflows / jobs 都定義在 <code>.circleci/config.yml</code> 中，使用這方式就可以分開定義比較複雜的 workflows / jobs)</p><p>接著根據變動的檔案，決定最後動態產生的檔案樣貌（ex. 若 <code>src/</code> 資料夾內檔案有變動，就會動態加上 <code>.circleci/code-config.yml</code> 這個檔案內容）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">2.1</span></span><br><span class="line"><span class="attr">setup:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">always-continue:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">build-code:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">build-docs:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">orbs:</span></span><br><span class="line">  <span class="attr">path-filtering:</span> <span class="string">circleci/path-filtering@1.0.0</span></span><br><span class="line">  <span class="attr">circleci-cli:</span> <span class="string">circleci/circleci-cli@0.1.9</span></span><br><span class="line">  <span class="attr">continuation:</span> <span class="string">circleci/continuation@1.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">setup:</span></span><br><span class="line">    <span class="attr">executor:</span> <span class="string">path-filtering/default</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">checkout</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Install the CircleCI CLI</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">circleci-cli/install</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 把 shared 裡面的內容結合成 shared-config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">shared</span> <span class="string">configuration</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">circleci</span> <span class="string">config</span> <span class="string">pack</span> <span class="string">.circleci/shared</span> <span class="string">&gt;&gt;</span> <span class="string">.circleci/shared-config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The mapping will be used to generate the dynamic configuration for all conditions that match.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path-filtering/set-parameters:</span></span><br><span class="line">          <span class="attr">base-revision:</span> <span class="string">pack-validate-continue-main</span></span><br><span class="line">          <span class="attr">config-path:</span> <span class="string">.circleci/no-updates.yml</span></span><br><span class="line">          <span class="attr">mapping:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">.*</span> <span class="string">always-continue</span> <span class="literal">true</span> <span class="string">.circleci/shared-config.yml</span></span><br><span class="line">            <span class="string">src/.*</span> <span class="string">build-code</span> <span class="literal">true</span> <span class="string">.circleci/code-config.yml</span></span><br><span class="line">            <span class="string">docs/.*</span> <span class="string">build-docs</span> <span class="literal">true</span> <span class="string">.circleci/docs-config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 根據上一部內容產生動態的 config 檔案</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">path-filtering/generate-config</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 驗證產生的檔案有沒有錯誤（Optionally）</span></span><br><span class="line">      <span class="comment"># <span class="doctag">note:</span> 上一步產生的東西會在 /tmp/generated-config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">Validate</span> <span class="string">config</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">circleci</span> <span class="string">config</span> <span class="string">validate</span> <span class="string">/tmp/generated-config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Continue the pipeline with the generated configuration.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">continuation/continue:</span></span><br><span class="line">          <span class="attr">configuration_path:</span> <span class="string">/tmp/generated-config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">setup-workflow:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">setup</span></span><br></pre></td></tr></table></figure><h2>我用他來幫助我解決了什麼問題？</h2><p>我們原本的流程（workflow）過於複雜，不同 workflow 的啟動條件包含大量條件判斷，讓人難以理解執行邏輯。</p><p>我將 parameters、commands 和 jobs 等基本組件抽離到 <code>shared_config.yml</code>，並且把流程啟動條件判斷拔除，把不同情境的流程分別定義在不同檔案中（檔案名稱本身也加強了可讀性），根據當下情況，產生最終的流程。</p><p>這樣的調整讓整體結構變得簡單易懂的同時，也降低了維護成本。</p><p>調整前後的檔案結構如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 調整前</span><br><span class="line">.circleci</span><br><span class="line">└──config.yml</span><br><span class="line"></span><br><span class="line"># 調整後</span><br><span class="line">.circleci</span><br><span class="line">├── config.yml</span><br><span class="line">├── config_original.yml</span><br><span class="line">├── shared_config.yml</span><br><span class="line">└── workflows</span><br><span class="line">    ├── pr_workflow.yml</span><br><span class="line">    ├── production_backend_deploy_workflow.yml</span><br><span class="line">    ├── production_frontend_deploy_workflow.yml</span><br><span class="line">    ├── staging_backend_deploy_workflow.yml</span><br><span class="line">    └── staging_frontend_deploy_workflow.yml</span><br></pre></td></tr></table></figure><h2>使用限制</h2><p>Dynamic Config 雖然強大，但也有一些限制，在 <a href="https://circleci.com/docs/dynamic-config/#config-continuation-constraints" target="_blank" rel="noopener">官方文件</a> 的眾多限制中，我想提出兩個我覺得最重要的限制：</p><ol><li>一個完整的 pipeline 中 <code>continue</code> 的動作只能做一次，無法無限串接。</li><li>使用 Dynamic Config 時，setup configuration 中只能啟動一個 workflow（可以透過條件判斷確保只有一個 workflow 被執行）。</li></ol><h2>心得</h2><p>在理解並使用 Dynamic Config 後，我認為這是 CircleCI 使用者都必須了解的功能。</p><p>不像 GitHub Actions 可以將 jobs 和 commands 拆分成多個檔案，CircleCI 原本的單一檔案管理方式非常痛苦。Dynamic Config 的出現，讓工程師能更靈活地拆分和動態控制 pipeline，大大提升了自動化流程的可維護性。</p>]]></content>
    
    
    <summary type="html">CircleCI Dynamic Config 介紹</summary>
    
    
    
    
    <category term="Devops" scheme="https://qoosuperman.github.io/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>用 Rails 實作 RAG 初體驗</title>
    <link href="https://qoosuperman.github.io/article/2024-11-28-%E7%94%A8%20Ruby%20%E5%AF%A6%E4%BD%9C%20RAG/"/>
    <id>https://qoosuperman.github.io/article/2024-11-28-%E7%94%A8%20Ruby%20%E5%AF%A6%E4%BD%9C%20RAG/</id>
    <published>2024-11-28T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.536Z</updated>
    
    <content type="html"><![CDATA[<p>我第一次接觸到 RAG 是在 <a href="https://hwdc.ithome.com.tw/2024" target="_blank" rel="noopener">Hello World Dev Conference</a> 的 workshop 中。雖然 workshop 只是簡單地帶我們實作從一個 PDF 檔案中搜尋內容，但這次體驗讓我了解到目前市場上常見解決方案背後的原理。為了進一步了解 RAG 的運作方式，我決定自己實作一個小小的 side project 試試看。</p><h2>RAG 是什麼？</h2><p>RAG，即 Retrieval-Augmented Generation，是一種結合檢索機制與生成模型的 AI 技術。傳統語言模型雖然功能強大，但其內部知識庫是固定的，可能會隨時間變得過時或不完整。RAG 透過兩個步驟解決這個問題：</p><ul><li>檢索：從外部知識來源（例如資料庫或文件庫）中找到相關且最新的資訊。</li><li>生成：利用檢索到的資訊生成答案，確保回答準確且與當前情境相關。</li></ul><p>這種檢索與生成的結合，使 AI 系統能產出更具時效性的答案，非常適合需要最新資訊的應用場景，例如客服支援、新聞更新或學術研究。目前，檢索步驟通常採用向量搜尋（vector search）技術來尋找相關資料。</p><h2>向量搜尋是什麼？</h2><p>向量資料庫使用向量表示每個物件，以保留資料的語義關係。將語意轉換成向量的過程稱為 embedding，而每個向量對應多維空間中的一個點。例如，在下圖中，香蕉的向量位置會比較靠近蘋果，而雞跟貓的向量位置會比較相近：</p><p><img src="https://hackmd.io/_uploads/HJ9bm5zNke.png" alt="image"></p><p>至於這些向量所在的多維空間到底有多少維度，目前最普遍被使用的 <code>OpenAI text-embedding-3-small</code> 模型提供 1536 維度，而進階的 text-embedding-3-large 模型則提供 3072 維度。這些高維度特性，能帶來更精確的結果。</p><h2>Steps</h2><p>RAG 通常由以下的步驟構成：</p><ul><li><strong>載入</strong>：使用工具（如 langchain 的 Document loader）載入資料。</li><li><strong>分割</strong>：使用 Text Splitter 將大型文件分成小片段，以利於索引及傳入模型處理，因為大型片段難以搜尋且不適合模型的 context window。</li><li><strong>儲存</strong>：需要一個儲存和索引這些片段的地方，以便日後進行搜尋。這通常使用向量資料庫和 embedding 模型來完成。</li><li><strong>檢索</strong>：根據使用者輸入，使用 Retriever 從儲存中獲取相關片段。</li><li><strong>生成</strong>：LLM 利用問題與檢索結果生成答案。</li></ul><p><img src="https://python.langchain.com/assets/images/rag_indexing-8160f90a90a33253d0154659cf7d453f.png" alt=""></p><p><img src="https://python.langchain.com/assets/images/rag_retrieval_generation-1046a4668d6bb08786ef73c56d4f228a.png" alt=""></p><p>在這次的 RAG demo 中，我使用 <a href="https://qoosuperman.github.io/">我的部落格</a> 的文章作為資料來源，並採用 Rails 作為網頁框架，向量資料庫則使用 <a href="https://qdrant.tech/" target="_blank" rel="noopener">Qdrant</a> 提供的免費雲端方案。</p><h2>Ruby Code</h2><h3><strong>載入</strong></h3><p>由於資料來源是 markdown 檔案，載入部分直接使用 Ruby 的 <code>File.read(file_path)</code> 方法。若使用更成熟的框架（如 Langchain），則可支援載入多種來源（如 PDF 或網頁）。</p><h3><strong>分割</strong></h3><p>一般來說，分割會將檔案切成多個小片段並儲存到向量資料庫，同時需維護檔案與資料庫間的關聯，方便日後更新。而為了簡化這個 side project，我只有在文章超過 token 限制時，將文章分段後使用 LLM 進行摘要，再將摘要儲存到向量資料庫中，如此一來我就不用使用另一個資料庫儲存相對應的關聯資訊。雖然這可能導致部分細節遺失，但對於這次 demo 已經足夠。</p><p>我使用的是 <code>langchainrb</code> 套件中的 <code>Chunker::RecursiveText</code> 來進行分段。順帶一提雖然 <code>langchainrb</code> 套件目前功能比 Python 的 Langchain 提供的功能陽春很多，但已能滿足我的大部分需求。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AITextSummarizer</span></span></span><br><span class="line">  CHUNK_SIZE = <span class="number">4000</span></span><br><span class="line">  CHUNK_OVERLAP_SIZE = <span class="number">200</span></span><br><span class="line">  SUMMARY_TOKENS = <span class="number">1000</span> <span class="comment"># Desired length of summary</span></span><br><span class="line">  OPENAI_MODEL = <span class="string">"gpt-4o-mini"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @client = OpenAI::Client.new(<span class="symbol">access_token:</span> ENV[<span class="string">"OPENAI_API_KEY"</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summarize</span><span class="params">(text)</span></span></span><br><span class="line">    chunks = split_into_chunks(text)</span><br><span class="line">    summaries = chunks.map &#123; <span class="params">|chunk|</span> summarize_chunk(chunk.text) &#125;</span><br><span class="line">    combine_summaries(summaries)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">split_into_chunks</span><span class="params">(text)</span></span></span><br><span class="line">    Langchain::Chunker::RecursiveText.new(text, <span class="symbol">chunk_size:</span> CHUNK_SIZE, <span class="symbol">chunk_overlap:</span> CHUNK_OVERLAP_SIZE, <span class="symbol">separators:</span> [ <span class="string">"\n"</span> ]).chunks</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">combine_summaries</span><span class="params">(summaries)</span></span></span><br><span class="line">    <span class="keyword">if</span> summaries.size == <span class="number">1</span></span><br><span class="line">      summaries.first</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      combined_summary = summaries.join(<span class="string">"\n\n"</span>)</span><br><span class="line">      summarize_summaries(combined_summary)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summarize_chunk</span><span class="params">(text)</span></span></span><br><span class="line">    summarize_with_prompt(text, <span class="string">"請把下面這段文字用繁體中文總結到大約 100 字："</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summarize_summaries</span><span class="params">(text)</span></span></span><br><span class="line">    summarize_with_prompt(text, <span class="string">"請把下面這段文字用繁體中文總結，盡量不要遺漏太多細節："</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summarize_with_prompt</span><span class="params">(text, prompt)</span></span></span><br><span class="line">    response = @client.chat(</span><br><span class="line">      <span class="symbol">parameters:</span> &#123;</span><br><span class="line">        <span class="symbol">model:</span> OPENAI_MODEL,</span><br><span class="line">        <span class="symbol">messages:</span> [</span><br><span class="line">          &#123; <span class="symbol">role:</span> <span class="string">"system"</span>, <span class="symbol">content:</span> <span class="string">"You are a helpful assistant that summarizes text."</span> &#125;,</span><br><span class="line">          &#123; <span class="symbol">role:</span> <span class="string">"user"</span>, <span class="symbol">content:</span> <span class="string">"<span class="subst">#&#123;prompt&#125;</span>\n\n<span class="subst">#&#123;text&#125;</span>"</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="symbol">max_tokens:</span> SUMMARY_TOKENS</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    response.dig(<span class="string">"choices"</span>, <span class="number">0</span>, <span class="string">"message"</span>, <span class="string">"content"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><strong>儲存</strong></h3><p>儲存資料需要嵌入模型（embedding model）將資料轉換為向量，然後將結果存入向量資料庫。在我的實作中，我將文章內容、標題及網址等相關資訊一起存入向量資料庫的 payload（可以想像成 metadata），這樣最後 LLM 回答問題時就可以直接告訴我相關的網址跟文章標題。</p><p>閱讀下面的程式碼前有幾點需要先知道</p><ol><li><code>langchainrb</code> 套件的 <code>Langchain::Vectorsearch::Qdrant</code> 會自動幫忙使用 llm 的 embedding model 轉成向量，所以只要提供使用的 llm API key 即可</li><li>Qdrant 的專有名詞<br>a. collection 是用來儲存 points 的集合，可以想像成是 RDBMS 裡面的 table<br>b. point 是在向量資料庫的最重要 entity，一個點包含了一個向量跟 payload，可以想像成是 RDBMS 裡面的 row</li><li>使用之後才發現 Qdrant 中 point 的 id 必須遵守幾種可能的格式（<a href="https://qdrant.tech/documentation/concepts/points/" target="_blank" rel="noopener">ref</a>），我這裡使用文章的發布日期轉成 uuid 作為 point 的 id，如此一來同一篇文章更新的時候，同樣的發布日期就可以直接取代舊的 point</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">add_point(<span class="symbol">file_name:</span> file_name, <span class="symbol">original_content:</span> content, <span class="symbol">extracted_content:</span> extracted_content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_point</span><span class="params">(<span class="symbol">file_name:</span>, <span class="symbol">original_content:</span>, <span class="symbol">extracted_content:</span>)</span></span></span><br><span class="line">  Langchain::VectorSearchClient.new(<span class="symbol">collection_name:</span> COLLECTION_NAME).add_point(</span><br><span class="line">    <span class="symbol">content:</span> extracted_content,</span><br><span class="line">    <span class="symbol">id:</span> uuid_for(original_content),</span><br><span class="line">    <span class="symbol">payload:</span> &#123;</span><br><span class="line">      <span class="symbol">title:</span> title_for(original_content),</span><br><span class="line">      <span class="symbol">url:</span> url_for(file_name)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前用建立時間作為 uuid 根據</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uuid_for</span><span class="params">(content)</span></span></span><br><span class="line">  datetime_str = content.match(<span class="regexp">/^date:\s*(.*)/</span>)[<span class="number">1</span>]</span><br><span class="line">  brief_datetime_str = DateTime.parse(datetime_str)</span><br><span class="line">                                .strftime(<span class="string">"%Y%m%d%H%M%S"</span>)</span><br><span class="line"></span><br><span class="line">  sha1_hash = Digest::SHA1.hexdigest(brief_datetime_str)</span><br><span class="line">  <span class="comment"># to make sha1 match uuid format</span></span><br><span class="line">  <span class="comment"># https://qdrant.tech/documentation/concepts/points/</span></span><br><span class="line">  <span class="string">"<span class="subst">#&#123;sha1_hash[<span class="number">0</span>..<span class="number">7</span>]&#125;</span>-<span class="subst">#&#123;sha1_hash[<span class="number">8</span>..<span class="number">11</span>]&#125;</span>-<span class="subst">#&#123;sha1_hash[<span class="number">12</span>..<span class="number">15</span>]&#125;</span>-<span class="subst">#&#123;sha1_hash[<span class="number">16</span>..<span class="number">19</span>]&#125;</span>-<span class="subst">#&#123;sha1_hash[<span class="number">20</span>..<span class="number">31</span>]&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Langchain</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">VectorSearchClient</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(<span class="symbol">collection_name:</span>)</span></span></span><br><span class="line">      <span class="comment"># default openai model: text-embedding-3-small</span></span><br><span class="line">      @qdrant = Langchain::Vectorsearch::Qdrant.new(</span><br><span class="line">        <span class="symbol">url:</span> ENV[<span class="string">"QDRANT_URL"</span>],</span><br><span class="line">        <span class="symbol">api_key:</span> ENV[<span class="string">"QDRANT_API_KEY"</span>],</span><br><span class="line">        <span class="symbol">index_name:</span> collection_name, <span class="comment"># Note: collection name 近似於 RDBMS 的 table name，用來儲存 points</span></span><br><span class="line">        <span class="symbol">llm:</span> Langchain::LLM::OpenAI.new(<span class="symbol">api_key:</span> ENV[<span class="string">"OPENAI_API_KEY"</span>])</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_point</span><span class="params">(<span class="symbol">content:</span>, <span class="symbol">id:</span>, <span class="symbol">payload:</span> &#123;&#125;)</span></span></span><br><span class="line">      @qdrant.add_texts(</span><br><span class="line">        <span class="symbol">texts:</span> [ content ],</span><br><span class="line">        <span class="symbol">ids:</span> [ id ],</span><br><span class="line">        <span class="symbol">payload:</span> payload</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><strong>檢索 &amp; 生成</strong></h3><p><code>langchainrb</code> 套件的 <code>Langchain::Vectorsearch::Qdrant</code> 模組會自動使用 LLM 的 embedding model 把問題轉成向量並進行相似度搜尋。搜尋結果返回後，LLM 將根據問題和檢索資料生成答案。</p><p>以下程式碼中的 k 表示從相似度搜尋中返回的 point 數量，LLM 會以這些 point 的資料作為生成答案的基礎。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuestionsController</span> &lt; ApplicationController</span></span><br><span class="line">  RELATED_POSTS_AMOUNT = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">    @client = Langchain::VectorSearchClient.new(<span class="symbol">collection_name:</span> <span class="string">"blog"</span>)</span><br><span class="line">    @response = @client.ask(<span class="symbol">question:</span> question_params, <span class="symbol">k:</span> RELATED_POSTS_AMOUNT).completion</span><br><span class="line">    respond_to <span class="keyword">do</span> <span class="params">|format|</span></span><br><span class="line">      format.turbo_stream</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Langchain</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">VectorSearchClient</span></span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ask</span><span class="params">(<span class="symbol">question:</span>, <span class="symbol">k:</span>)</span></span></span><br><span class="line">      @qdrant.ask(<span class="symbol">question:</span> question, <span class="symbol">k:</span> k)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2>Demo</h2><p>以上就是這個小專案中跟 RAG 有關的部分。</p><p>在 UI 實作方面，，我使用 Rails 搭配 <a href="https://turbo.hotwired.dev/" target="_blank" rel="noopener">Turbo</a> 來作出簡單的問答頁面，成果長得像下面這樣：</p><p>問問題的頁面：</p><p><img src="https://hackmd.io/_uploads/S1n071LXJx.png" alt="image"></p><p>LLM 回答的結果：</p><p><img src="https://hackmd.io/_uploads/rkT371Lmkx.png" alt="image"></p><p>從上面的圖片可以看到因為我有給他文章網址，因此他在回答的時候也能提供這部分的資訊。</p><h2>心得</h2><p>實作這個小專案的過程中，我才真正體會到開發一個 RAG 應用程式時需要注意的各種細節。例如，當一篇文章被更新時，如何有效地同步更新向量資料庫中的相關資料，以及針對長篇文章，有哪些分割方法可以使用，而哪些方法的效果大家實驗後覺得較為理想，這些都是值得研究的議題。</p><p>接下來，我計劃進一步學習 LangChain 的使用方式，透過實作幾個小應用來熟悉他。接著希望能深入了解實作細節和所使用的 prompt 等等，可能未來能更靈活地應用到其他專案中。</p><h2>References</h2><p><a href="https://weaviate.io/blog/distance-metrics-in-vector-search" target="_blank" rel="noopener">向量搜尋介紹</a><br><a href="https://python.langchain.com/docs/introduction/" target="_blank" rel="noopener">LangChain document</a></p>]]></content>
    
    
    <summary type="html">用 Rails 實作 RAG 初體驗</summary>
    
    
    
    
    <category term="Rails" scheme="https://qoosuperman.github.io/tags/Rails/"/>
    
    <category term="AI" scheme="https://qoosuperman.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Rails Turbo 學習心得</title>
    <link href="https://qoosuperman.github.io/article/2024-10-24-Rails%20Turbo%20%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/"/>
    <id>https://qoosuperman.github.io/article/2024-10-24-Rails%20Turbo%20%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</id>
    <published>2024-10-24T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.536Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JQp6XIth7EpK6KsWxLkKA.png" alt="rails turbo"></p><p>最近準備要做個小小的 side project</p><p>快要做到前端的時候想到自己其實還不會用目前 Rails 生態系推薦的 Hotwire 系列工具，因此這兩週就花了些時間研究了一下（如果要學的話推薦學習資源放在最下面）</p><p>以下記錄一下重點跟使用心得</p><h2>Hotwire</h2><p>Hotwire 指的是 <code>HTML over the wire</code>，與傳統 JavaScript 透過 API 獲取 JSON 資料並處理的方式不同，Hotwire 是直接通過 API 獲取 HTML，然後將其渲染在頁面上。</p><p>它包含三個主要框架：</p><ul><li><strong>Turbo：</strong> 負責處理頁面導航和更新，透過伺服器傳送 HTML 來動態更新頁面，並加速連結和表單提交，只更新需要的部分，避免整頁重新載入。</li><li><strong>Stimulus：</strong> 用於處理需要用戶端互動的場景，是一個輕量級的 JavaScript 框架。</li><li><strong>Strada：</strong> 用於將網頁互動升級到原生應用程式。</li></ul><p>在 Rails 中，他認為大部分情境下開發者會使用 Turbo，真的需要寫 Javascript 的時候寫 Stimulus JS，要寫手機作業系統的時候才會用到 strada。</p><p>這篇文章主要在研究 Turbo 的使用方式。</p><h2>Turbo</h2><p>Turbo 又分成三個部分</p><ul><li><strong>Turbo Drive</strong>: 是 Turbo 的核心，它透過攔截連結點擊和表單提交，在背景執行要做的事情來更新頁面，無需整頁重載</li><li><strong>Turbo Frame</strong>: 把頁面拆成多個部分，點擊連結或者送出表單之後，只有特定區域的地方會做更新</li><li><strong>Turbo Streams</strong>: 透過 WebSocket、SSE（Server-Sent Events） 或表單提交傳遞 HTML 片段來更新頁面</li></ul><h3>Turbo Drive</h3><p>Turbo Drive 前一代的祖先是 Turbolink，但那時候只有處理連結，現在 Turbo Drive 額外支援表單的請求</p><p>Turbo Drive 做了幾件事情：</p><ol><li>防止瀏覽器跟隨連結</li><li>使用歷史紀錄 API 更改瀏覽器 URL</li><li>使用 fetch 請求獲取新頁面</li><li>通過替換當前 <code>&lt;body&gt;</code> 元素和合併 <code>&lt;head&gt;</code> 元素的內容來渲染回應的 HTML</li></ol><p>當只替換 <body> 內容時，<head><meta name="generator" content="Hexo 3.9.0"> 標籤內的內容通常不會變動，因此不需要重新下載字體、CSS、JS 等文件，這能加快頁面渲染速度。<link rel="alternate" href="/atom.xml" title="Anthony Chao" type="application/atom+xml"></head></body></p><p>然而，當 JS 或 CSS 發生變動時，我們希望能重新載入整個頁面。Turbo Drive 會在每次新請求時，對比當前頁面與回應頁面中 <head><meta name="generator" content="Hexo 3.9.0"> 內標記為 data-turbo-track=“reload” 的 DOM 元素，若發現差異就會重新載入頁面。</head></p><p>所以我們可以看到目前在 Rails layout 中，css / js 都加上了這個屬性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%#</span> <span class="attr">app</span>/<span class="attr">views</span>/<span class="attr">layouts</span>/<span class="attr">application.html.erb</span> %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">stylesheet_link_tag</span> "<span class="attr">application</span>", "<span class="attr">data-turbo-track</span>"<span class="attr">:</span> "<span class="attr">reload</span>" %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">javascript_include_tag</span> "<span class="attr">application</span>", "<span class="attr">data-turbo-track</span>"<span class="attr">:</span> "<span class="attr">reload</span>", <span class="attr">defer:</span> <span class="attr">true</span> %&gt;</span></span><br></pre></td></tr></table></figure><h3>Turbo Frame</h3><p>它透過替換具有相同 ID 的 <code>&lt;turbo-frame&gt;</code> 標籤內容來更新頁面。</p><p>已下面的範例程式碼來說</p><p>_task.html.erb 完全被 turbo frame tag 包住，所以如果點擊 <code>Edit</code> 按鈕會全部被替換掉，而替換的內容就是 edit.html.erb 頁面中有著同樣 id 的 turbo frame tag 的部分</p><details>  <summary>範例程式碼</summary><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% index.html.erb %%</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tasks"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"font-bold text-lg mb-7"</span>&gt;</span>Tasks<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"px-5"</span> <span class="attr">data-controller</span>=<span class="string">"tasks"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">render</span> @<span class="attr">tasks</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%% _task.html.erb %%</span><br><span class="line"><span class="tag">&lt;<span class="name">turbo-frame</span> <span class="attr">id</span>=<span class="string">"&lt;%= dom_id task %&gt;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block mb-2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">form_with</span>(<span class="attr">model:</span> <span class="attr">task</span>, <span class="attr">class:</span>"<span class="attr">text-lg</span> <span class="attr">inline-block</span> <span class="attr">my-3</span> <span class="attr">w-72</span>") <span class="attr">do</span> |<span class="attr">form</span>| %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">task.description</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">end</span> %&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">link_to</span> "<span class="attr">Edit</span>", <span class="attr">edit_task_path</span>(<span class="attr">task</span>),</span></span><br><span class="line"><span class="tag">                <span class="attr">class:</span> "<span class="attr">btn</span> <span class="attr">bg-gray-100</span>"</span></span><br><span class="line"><span class="tag">    %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inline-block ml-2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">button_to</span> "<span class="attr">Delete</span>", <span class="attr">task_path</span>(<span class="attr">task</span>),</span></span><br><span class="line"><span class="tag">                    <span class="attr">method:</span> <span class="attr">:delete</span>,</span></span><br><span class="line"><span class="tag">                    <span class="attr">data:</span> &#123; "<span class="attr">turbo-frame</span>"<span class="attr">:</span> "<span class="attr">_top</span>" &#125;,</span></span><br><span class="line"><span class="tag">                    <span class="attr">class:</span> "<span class="attr">btn</span> <span class="attr">bg-red-100</span>" %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">turbo-frame</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%% edit.html.erb %%</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"font-bold text-2xl mb-3"</span>&gt;</span>Editing Task<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">turbo-frame</span> <span class="attr">id</span>=<span class="string">"&lt;%= dom_id @task %&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">render</span> "<span class="attr">form</span>", <span class="attr">task:</span> @<span class="attr">task</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">link_to</span> "<span class="attr">Never</span> <span class="attr">Mind</span>", <span class="attr">tasks_path</span>, <span class="attr">class:</span> "<span class="attr">btn</span> <span class="attr">mb-3</span> <span class="attr">bg-gray-100</span>" %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">turbo-frame</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>另外若要替換整個頁面，可以使用 <code>data-turbo-frame=&quot;_top&quot;</code> 屬性。</p><p>通常點擊連結之後，會跟包覆著連結的 turbo frame tag 互動，但也可以指定不是包覆這連結的 frame，這時候可以用 <code>data: { turbo_frame: ...}</code> 這個屬性</p><details>  <summary>範例程式碼</summary><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"font-bold text-2xl inline-block"</span>&gt;</span>Quotes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%=</span> <span class="attr">link_to</span> "<span class="attr">New</span> <span class="attr">quote</span>",</span></span><br><span class="line"><span class="tag">                  <span class="attr">new_quote_path</span>,</span></span><br><span class="line"><span class="tag">                  <span class="attr">class:</span> "<span class="attr">btn</span> <span class="attr">btn--primary</span>",</span></span><br><span class="line"><span class="tag">                  <span class="attr">data:</span> &#123; <span class="attr">turbo_frame:</span> <span class="attr">dom_id</span>(<span class="attr">Quote.new</span>) &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mt-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">turbo_frame_tag</span> <span class="attr">Quote.new</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%=</span> <span class="attr">render</span> @<span class="attr">quotes</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h3>Turbo Stream</h3><p>Turbo Stream 可以將 HTML 片段發送到頁面上，替換或修改現有內容。它專門用於在單次請求中更新頁面多個部分的情況。</p><p>跟 turbo frame 的差異有幾點</p><ol><li>Turbo frame 一次只能替換已經存在的 frame，不能做 append / prepend 的動作</li><li>Turbo stream 還可以用 websocket 來更新頁面（當然也可以用 POST request 來更新）</li></ol><p>turbo stream 的核心也是靠 HTML snippet 來實現，但跟 turbo frame 不同，turbo stream tag 中一定包含一個 action，所有的 action 都需要一個 target 來指定對象（只有 refresh 這個 action 不需要）</p><p>這是 turbo stream tag 在 HTML 中的長相：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">turbo-stream</span> <span class="attr">action</span>=<span class="string">"action_to_take"</span> <span class="attr">target</span>=<span class="string">"element_to_update"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"element_to_update"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Some more html --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">turbo-stream</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這裡的實現比較複雜一些，推薦要看使用範例的話直接看 <a href="https://www.hotrails.dev/turbo-rails" target="_blank" rel="noopener">Turbo Rails Tutorial</a> 裡面有滿多的範例</p><h2>心得</h2><p>總算是大致上理解了這套系統如何使用，但在好不容易理解完後，我應該只會在小專案嘗試使用 Turbo</p><p>因為在複雜專案中，前端效果經常是巢狀結構，而要使用 Turbo 處理這種巢狀效果的話想向上維護起來有點困難</p><p>此外，複雜專案中常需重複使用同樣的元件，因此以 component-based 的前端框架會更容易維護</p><h2>References</h2><p><a href="https://courses.writesoftwarewell.com/p/hotwire-handbook" target="_blank" rel="noopener">Hotwire Crash-Course</a><br><a href="https://www.hotrails.dev/turbo-rails" target="_blank" rel="noopener">Turbo Rails Tutorial</a><br><a href="https://www.youtube.com/watch?v=ZEZY_tKNjMo" target="_blank" rel="noopener">卡米哥 demo</a><br><a href="https://turbo.hotwired.dev/handbook/introduction" target="_blank" rel="noopener">Turbo 官方文件</a></p>]]></content>
    
    
    <summary type="html">Rails Turbo 學習心得</summary>
    
    
    
    
    <category term="Rails" scheme="https://qoosuperman.github.io/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>Shape Up 書摘</title>
    <link href="https://qoosuperman.github.io/article/2024-10-14-Shape%20Up%20%E6%9B%B8%E6%91%98/"/>
    <id>https://qoosuperman.github.io/article/2024-10-14-Shape%20Up%20%E6%9B%B8%E6%91%98/</id>
    <published>2024-10-14T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p><img src="https://basecamp-goods.com/cdn/shop/products/shap-up-fan-01_grande.png?v=1601482900" alt="shape up"></p><p>前陣子看 ruby newsletter 發現 BaseCamp 團隊出了一本書叫做 <a href="https://basecamp.com/shapeup" target="_blank" rel="noopener">Shape Up</a>，看起來跟軟體開發團隊的功能規劃跟執行有關，正好那陣子有相關的討論反覆在 retro meeting 被提起，當時想著也許這本書能提供我們一些不同的觀點，因此找了同事一起第一次辦了讀書會一起看這本書，結束之後覺得收穫豐富，也推薦大家可以閱讀一下！</p><h2>Shape Up 重點整理</h2><p><strong>1. 塑造（Shaping）</strong></p><p>在 Shape Up 中，Shaping 階段非常重要，它發生在實際開發工作開始之前。  這個階段的目標是將模糊的想法轉化為具體的、可執行的專案提案。</p><ul><li><strong>界定問題：</strong> 塑造的第一步是明確界定要解決的問題，並思考解決方案的價值。 這包括判斷這個功能是否值得投入時間開發，大小必須符合他們制定的週期（六週），以及是否有更簡單的替代方案。</li><li><strong>找出 key element：</strong>  下一步是找出解決方案的 key element。  這個過程需要使用一些工具，例如「Breadboarding」和「Fat marker sketches」。  「Breadboarding」是指用文字描述使用者介面和互動流程，而「Fat marker sketches」則是用粗略的圖像來呈現設計概念。  這些工具可以幫助團隊在不陷入細節的情況下，快速探索不同的設計可能性。</li><li><strong>預先思考風險：</strong>  塑造的最後一步是預先思考可能的風險和漏洞。  團隊需要仔細審視設計方案，找出可能導致開發延遲或失敗的因素，並在開發前盡可能解決這些問題。  書中建議可以邀請技術專家參與這個過程，以確保技術方案的可行性。</li></ul><p>breadboarding 指的是模仿電路板的道理，在沒有明確設計的情況下來草擬 / 討論 key component，範例為自動結帳功能：</p><p><img src="https://hackmd.io/_uploads/S1x8JLf9A.png" alt="image"></p><p>Fat marker sketches 則適用在腦中的點子不是文字而是圖像的時候，建議用馬克筆直接畫草稿，範例為日曆功能：</p><p><img src="https://hackmd.io/_uploads/rJghMIMcA.png" alt="image"></p><p><strong>2. 賭注（Betting）</strong></p><p>塑造階段完成後，他們捨棄傳統的 backlog 模式，團隊會將提案提交到「賭注會議」上，由決策者決定哪些提案值得投入時間開發。  這個過程類似於我們之前討論中提到的「賭注會議」。</p><ul><li><strong>提案篩選：</strong> 在賭注會議上，決策者會根據提案的重要性、可行性、時間成本等因素，決定哪些提案值得開發。  書中提到，Basecamp 的決策者會考慮以下問題：這個問題真的重要嗎？預計的開發時間是否合理？解決方案是否具有吸引力？現在是否是開發這個功能的最佳時機？是否有合適的團隊成員可以執行？</li><li><strong>控制風險：</strong>  他們團隊認為，開發新產品和既有產品的功能應該採取不同的賭注策略。  對於新產品，Basecamp 會先進行研發階段，以驗證產品概念的可行性，然後再進入正式開發階段。  這種做法可以幫助團隊降低開發新產品的風險。</li><li><strong>Cool down：</strong>  在每個週期結束之後，他們不會馬上進下一個週期，而是兩週的 cool-down 時間，主要用來規劃下次要做什麼 / 開賭注會議，這期間開發者跟設計師可以做一些想做的事情，比方說修 bug / 找新點子 / 試試新技術</li></ul><p><strong>3. 建構（Building）</strong></p><p>一旦提案在賭注會議上獲得批准，就會進入建構階段，由開發團隊負責將提案轉化為實際產品。</p><ul><li><strong>專注於核心功能：</strong>  從最有意義的開始做，把最重要的核心想辦法做到可以 demo 的程度，過程中盡量每個人可以獨立作業不被卡住（ex. 前端依靠 shaping 來實作出概念而不是依賴設計稿，後端不用先設計資料庫欄位）</li><li><strong>進度視覺化：</strong>  為了讓專案進度視覺化，BaseCamp 團隊自創了山丘圖（Hill chart）的概念，上坡代表還在探索需要解決的問題，下坡代表探索完畢處於執行階段</li><li><strong>以用戶需求為核心：</strong> 專案完成應以解決用戶實際問題為標準，而不僅僅追求理想的功能。同時，減少不必要的實作範圍並不會降低質量，反而能讓團隊聚焦於核心功能，提升產品的競爭力。</li></ul><p>作者認為應該前後端團隊首先專注完成一個可呈現的功能：</p><p><img src="https://hackmd.io/_uploads/rJQTIU-1kl.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/r1NC8U-y1g.png" alt="image"></p><p>山丘圖的上坡部分還在探索有哪些待辦事項，下坡就是執行階段，他們會把不同 scope 放在這個山丘圖中，讓 PM 去檢視每個不同 scope 目前的進度</p><p><img src="https://hackmd.io/_uploads/rk4zZsEnC.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/BkZvWjEnC.png" alt="image"></p><h2>個人想法</h2><ol><li>透過跟團隊一起閱讀過這本書並討論，更可以理解 PM / 設計師的工作流程跟專注點有哪些地方跟工程師不同，覺得光是這件事情就很有收穫。</li><li>他們認為的理想流程無法百分之百適用於每個團隊，我們認為影響的因素包括但不限於團隊大小 / 團隊體質 / 產品特性。</li><li>先為這個功能設定 appetite 我覺得很適用在我自己實驗 side project 身上，過往很容易想做的東西太多最後懶惰而失敗，如果先鎖定一個期限，為這個期限設定一個合理的範圍，也許會是一個比較容易成功的路徑。</li></ol>]]></content>
    
    
    <summary type="html">Shape Up 書摘</summary>
    
    
    
    
    <category term="Developer" scheme="https://qoosuperman.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>Key Take Away from 2024 DDD TW Conf</title>
    <link href="https://qoosuperman.github.io/article/2024-09-17-Key%20take%20away%20in%202024%20DDD%20TW%20conf/"/>
    <id>https://qoosuperman.github.io/article/2024-09-17-Key%20take%20away%20in%202024%20DDD%20TW%20conf/</id>
    <published>2024-09-17T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>上週參加了 2024 台灣領域驅動設計年會，覺得收穫滿滿！</p><p>有些議程專門給剛開始接觸 DDD 的新手，像是說明 DDD 裡面提供的 design pattern 如何運用，也有人在講自己專案中導入 DDD 的實戰經驗，更多的是分享自己的一些見解（ex. 團隊拓墣 / 開發者體驗 …etc）</p><p>另外比較特別的還有 panel discussion 找一些專家討論遺留工作負載這個議題</p><p>這篇文章中挑了兩場演講記錄一些重要的 take away 分享給看到這篇文章的大家，同時也作為自己往後的 memo（註：礙於知識產權，不方便直接分享投影片截圖出來）</p><h2>開發者體驗(DevEx)</h2><p>開發者體驗的廣義定義為：視開發者為 End user，將工作過程的技術協作與團隊協作看做產品與服務，關注 developer 在使用中的感知與反應；致力於消除這些產品與服務所帶來的摩擦力，進而能夠快速交付價值並獲得回饋</p><p>開發者體驗不佳的結果：</p><ul><li>專注於個人項目：轉移注意力到自己能控制的項目上。</li><li>驗證負面體驗：接受並承認當前的負面體驗。</li><li>加班：通過加班來完成工作以減少壓力。</li><li>停止發聲：減少反饋或提出問題，避免與問題對抗。</li><li>減少參與：減少在團隊活動中的參與度。</li><li>利用系統漏洞：利用組織中的漏洞來達到自己的工作目標。</li><li>離職：當問題無法解決時，選擇離開公司。</li></ul><p>講者認為 DevEx 主要由三個要點組成：</p><ol><li>心流狀態</li><li>回饋循環</li><li>認知負荷</li></ol><h3>心流狀態</h3><p>影響心流狀態的因素非常多．包括但不限於：</p><ul><li>心理安全（ex. 公司總是處在不穩定狀態，也很難進入心流）</li><li>工作中斷頻率</li><li>開發工具摩擦</li><li>任務清晰度</li><li>好的 CICD 流程</li></ul><p>讓自己進入心流的要點：</p><ul><li>挑戰與技能匹配：選擇一個挑戰難度與你當前技能水平相匹配的任務。</li><li>設置清晰的目標：確保每個任務前有明確方向</li><li>即時回饋：在行動中，能夠持續獲得反饋是關鍵。</li><li>專注於當下：心流的實現需要你全神貫注於當下的活動。消除外界的干擾，專注於眼前的任務，將有助於你快速進入心流狀態​。可以使用單核工作法 / 番茄工作法</li></ul><h3>認知負荷</h3><p>包括但不限於：</p><ul><li>程式碼複雜性</li><li>文件易讀性</li><li>需要高專業知識的任務</li></ul><p>認知負荷可以分成三種：</p><ul><li>內在負荷：跟任務本身複雜性有關，是無可避免的</li><li>外在負荷：跟學習環境 / 方式有關，通常是可以減少的</li><li>額外負荷：有助於學習跟理解的負荷，應積極管理以提升學習效果</li></ul><p>講者認為，認知升級是人類（工程師）最好的投資，對於工程師來說，認知升級意味著不斷更新知識結構、拓展思維方式以及提升問題解決能力，這些都是在職業生涯中取得長遠成功的關鍵。</p><p>講者又認為，解決認知負荷最好的方式是找到 mentor，不管是在專案內，或者人生中，一定要找到人生的 mentor 解決認知負荷</p><h3>回饋循環</h3><p>包括但不限於：</p><ul><li>自動化測試速度</li><li>本地變更驗證時間</li><li>程式碼 review 週期時間</li><li>任務切換次數</li></ul><h2>新專案使用 DDD 的經驗談</h2><p>在做產品的時候，往往不是領域專家的知識變成產品，而是開發者心中的想像變成產品</p><p>而 DDD 的主要目的是為了減少產生出來的產品跟 PM 心目中產品的落差，所以雖然 DDD 介紹了很多工具，但他的開發啟動是從跟領域專家的對話開始</p><h3>講者導入之後的心得</h3><ol><li>業務複雜度高的情況下用 DDD 不一定變慢，且更快得到驗證</li><li>Ubiquitos language 是有意義的追求<ul><li>當發現雞同鴨講的時候，先停下來對名詞</li><li>文件用錯辭的時候，馬上改正</li></ul></li><li>快速頻繁驗證<ul><li>API First Design，前後端儘量不要成爲互相的瓶頸</li><li>In-memory prototype，最後才做 Table Schema Design 並接上真的 Database</li></ul></li><li>跟領域專家一起定義 scope 是專案成功的關鍵之一</li><li>實際情況往往會超出書本的定義，這時候仰賴當事人跟團體決策，不用執著在 DDD 的教條，要懂得妥協</li></ol><h3>Architectural Decision Records(ADR)</h3><ul><li>用於記錄「架構決策」</li><li>架構就是跟重要的事情有關的事物</li><li>記錄「Why」而非 「How」、「What」，通常會有幾個選項做選擇。</li><li>提醒未來的自己爲何當初要這這麼做，避免踩到坑或是提供充分資訊做決定。</li><li>寫什麼？架構設計、使用新套件、命名規範…</li><li>何時寫？只要有疑慮，就寫 (by Shopify Engineering)</li></ul><h3>整理軟體缺陷的來源</h3><p>軟體缺陷來源主要有四種</p><ol><li>Programmer errors</li></ol><ul><li>例：演算法寫錯、錯字、邏輯錯誤、改 A 壞 B</li></ul><ol start="2"><li>Design errors</li></ol><ul><li>例：技術債、過度設計與複雜</li></ul><ol start="3"><li>Requirements errors</li></ol><ul><li>例：結果與規格書定義不同，或規格書本身就不完整或有錯誤</li></ul><ol start="4"><li>Systemic errors (escaped defects)</li></ol><ul><li><p>例：資安漏洞、主機掛掉、第三方服務失效</p></li><li><p>良好習慣 For Programmer Errors</p><ol><li>從規格書把業務邏輯都要進入 Unit Tests 中，一條對一個 unit test<ul><li>主要以測試 Use Case 層爲主</li><li>加強 Unhappy Path 測試</li><li>Unit Test 也要用 Ubiquitous Language 命名，且盡可能提高可讀性</li></ul></li><li>Code Review 時審核變數命名盡可能符合 Ubiquitous Langauge</li><li>加上 Linter、Type Checker 減少錯誤的發生</li><li>補上 E2E Tests (Robot Framework)，覆蓋 Happy Cases</li></ol></li><li><p>建立設計原則 For Design Errors</p><ol><li>與團隊一同建立</li><li>遵守分層原則、Simple Design</li><li>定期 Refactoring 討論會議，在每一季度前排入工程票。</li><li>儘量減少不必要的 Interface 與 Class，保持數量越少、內容越簡單越好。</li></ol></li><li><p>套用 Specification By Example(SBE) 流程促進溝通提升規格書品質</p><ol><li>功能進開發前，會進入四個關卡：<ul><li>PM 交出初版 Requirement</li><li>PM、Developer、QA 一同討論規格、找出實例、探索風險（Example Mapping）</li><li>Developer 完善 (Refine) Requirement、討論 API 規格</li><li>Developer 拆出技術票</li></ul></li><li>工程師提早加入參與，可以提出替代方案來降低技術難度、加快上線速度以及提升品質。<ul><li>PM：提早與工程師討論可以儘快獲得回饋、降低獨自做決策的壓力，也能產出更完善的規格書</li><li>QA：大約 80% 以上的測資都在 Example Mapping 都找出來了，只要工程師照着開發，我就能專心測試更極端的案例。</li></ul></li></ol></li><li><p>定期 Retro 來解決 Systemic Errors</p><ol><li>團隊不分職位一起進行探索性測試，包含驗證格式主題、使用流程主題、易用性主題等等…</li><li>每次 Retro 都包含本次 Sprint 的 Bug 數，包含：<ul><li>QA 驗出來的 Bug</li><li>線上發生的 Bug</li><li>緊急的 Bug</li></ul></li><li>盡可能從流程面去避免這些問題，比如：<ul><li>當後端提供的 API 時常一有其他更動就壞掉：以後後端 PR 都要附上 API Result 截圖。</li><li>當問題多出在串接的 Y 團隊：下次接洽時，要先對他們的 API 進行一定程度測試以及時程確認？</li><li>DB Migration Script 內容有誤：將 Migration Script 加入 Git Version Control</li></ul></li><li>又或者從使用者 Feedback 獲得更多資訊</li></ol></li></ul>]]></content>
    
    
    <summary type="html">Key Take Away from 2024 DDD TW Conf</summary>
    
    
    
    
    <category term="Developer" scheme="https://qoosuperman.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>Hokaido Travel Notes</title>
    <link href="https://qoosuperman.github.io/article/2024-06-17-Hokaido_Travel_Notes/"/>
    <id>https://qoosuperman.github.io/article/2024-06-17-Hokaido_Travel_Notes/</id>
    <published>2024-06-17T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>第一次的北海道之旅，第一次自駕旅遊，第一次在國外跟友人會合一起玩樂</p><p>這次旅遊的三個關鍵字：溫泉 / 清酒 / 生活<br>每天都壓線 checkout（甚至 10 分鐘前還在泡湯），晚上睡覺前邊喝便利商店買來的清酒一邊思考明天要去哪裡晃晃，像日本阿北在躺在溫泉旁的石椅上散熱覺得很融入，買了很多北海道小精靈的小廢物週邊，晚上才發現照片裡面好多自己被卡掉的畫面碎碎念，因為便利商店買的清酒送的小杯子材質不是塑膠而是玻璃感到非常開心，種種的一切回想起來都很開心！</p><p>感謝老婆注意到許多我沒注意的小細節並幫忙安排，還有配合我的隨性，沒有制定每天的行程，果然因為這樣帶來許多的驚喜！<br>感謝小倢特地從東京來找我們，很開心知道你喜歡睡前小酌的活動，也感謝你在最後一天帶我們去非觀光客會知道的小店，並因此見到了非常熱情的北海道人，下次再依修尼吧！</p><p>朋友看到我們在小樽慢跑，說感覺好像我們在這裡生活一樣，但確實這就是我喜歡的旅遊方式</p><p>以下是自己每天的隨筆：</p><h2>行程</h2><h3>Day1</h3><p>新千歲機場 -&gt; 小樽 -&gt; check in -&gt; 吃<a href="https://g.co/kgs/6RqoPzr" target="_blank" rel="noopener">居酒屋 Rakuten</a> -&gt; 泡飯店溫泉 -&gt; 吃冰棒 -&gt; 吃宵夜拉麵</p><p>老婆在機場找到了公共鋼琴小露一手 👋</p><p>接著在火車上發現我的手機雖然裝了 eSIM 卡，但無法上網，用火車 wifi 聯繫客服，前前後後用了兩個多小時，直到小樽都無法使用，最後只好請他退費，這算是旅途中最不順的部分</p><p>到了小樽，發現這裡的店非常早關，到了晚上六點左右，大部分的店面就已經關門了。看來只能明天再逛逛</p><p>這天的住宿是 <a href="https://www.japanican.com/hotel/japan/otaru/dormy-inn-premium-otaru?cid=1839029" target="_blank" rel="noopener">Dormy Inn Premium Otaru</a>，這間是離車站最近的飯店，雖然房間小，但有提供室內跟露天溫泉，泡完溫泉後的休息室也很舒服。泡完溫泉可以吃免費的冰棒（早上則是乳酸飲料），宵夜還有免費的小小碗鹹拉麵可以吃。這間的早餐 buffet 特別出名，因為可以自己做生魚片 / 鮭魚卵蓋飯，但因為我當天吃到的鮭魚卵覺得腥味有點重，所以反而覺得早餐還好，但整體而言滿推薦的</p><h3>Day2</h3><p>小樽運河慢跑 -&gt; 吃飯店早餐 buffet -&gt; 泡湯 -&gt; check in 另外一間飯店 -&gt; 買 SIM 卡失敗 -&gt; 逛小樽 -&gt; 想吃哈密瓜蛋糕失敗 -&gt; 回飯店喝 free hour -&gt; 晚餐</p><p>一大早就跟老婆去慢跑，所有店都還沒開，用這樣的方式探索新地方感覺格外新鮮！回去再次泡湯之後，把行李拿去下一間飯店寄放，接著查到幾個街區外有個 Docomo，好不容易走到了（路上還下雨）卻發現裡面沒有賣給外國人的短期 SIM 卡，看來只能暫時過著寄生各地 WiFi 的生活</p><p>接著回到小樽的觀光區域，終於開始購物行程，這裡值得買的東西挺多的，像是音樂盒 / 玻璃製品 / 皮革製品。途中進了LeTAO咖啡廳，打算品嚐夏季限定的哈密瓜起司蛋糕，結果賣光，於是我們決定隔天早上再挑戰！</p><p>第二天的飯店是 <a href="https://www.livelyhotels.com/en/unwindotaru/" target="_blank" rel="noopener">UNWIND HOTEL&amp;BAR OTARU</a>，本身是古蹟改建，很有藝術感，我們住到的房間還有挑高，讓人感覺很寬敞，最值得讚賞的是有提供 free hour，紅白酒各三款無限暢飲，滿值得推薦的</p><p>這天的晚餐選到 <a href="https://tw.savorjapan.com/0011000168/" target="_blank" rel="noopener">和牛黑澤</a> 這間餐廳，吃了炸牛排定食跟鰻魚飯。這個炸牛排真是驚為天人，雖然外皮已經炸至酥脆，但牛排還是生的，會給你小烤盤自己加熱側邊，外皮的酥脆加上牛排的香氣真是不得了，會很想再去吃</p><h3>Day3</h3><p>吃 LeTAO 早餐 -&gt; 前往札幌 -&gt; check in -&gt; 午餐 <a href="https://tw.visit-hokkaido.jp/destinations/soup-curry-suage" target="_blank" rel="noopener">Suage+</a> -&gt; 買sim卡uniqlo,muji -&gt; 晚餐 <a href="https://gurunavi.com/zh-hant/h062000/mn/menu1/rst/?__ngt__=TT1571e8dfe003ac1e4ae781VoxOl-zdhFFw_TAOS55hqf" target="_blank" rel="noopener">直營千歲鶴</a> -&gt; 酒吧續攤 -&gt; 買夜間麵包</p><p>一早就去 LeTAO 吃昨天沒吃到的哈密瓜起士蛋糕，然後老婆點了一個早餐限定，搭配小樽玻璃藝品的甜點，這套甜點還有個彷彿藝術品的名字「息吹」，有夠浮誇 XDD，不過我們兩人都覺得這兩樣東西非常好吃！拿來當作早餐享用很幸福</p><p>接著就啟程前往札幌，並吃了北海道有名的湯咖哩 <a href="https://tw.visit-hokkaido.jp/destinations/soup-curry-suage" target="_blank" rel="noopener">Suage+</a>。其實我覺得吃起來的味道跟印象中的咖哩差距滿大的，香料的味道不太相同，能理解他的好吃，但我還是比較喜歡濃稠的 XD</p><p>接著去 Big Camera 終於買到了實體 Sim 卡解決了網路問題</p><p>隨意逛逛 Uniqlo / MUJI 之後，去吃 <a href="https://gurunavi.com/zh-hant/h062000/mn/menu1/rst/?__ngt__=TT1571e8dfe003ac1e4ae781VoxOl-zdhFFw_TAOS55hqf" target="_blank" rel="noopener">直營千歲鶴</a>，他是一間千歲鶴酒廠直營的居酒屋，非常非常的推薦，清酒好喝，食物非常好吃又很划算，特別推薦他們的烤馬鈴薯搭配起士，我們總共大概吃了三間的烤馬鈴薯，這間最好吃</p><p>後來又去了另一間酒吧續攤，覺得沒特別好喝又很貴，還會強行給你餅乾當作下酒菜而且收頗貴的費用，就不提了</p><p>我們在札幌住三天，住的是星野集團的 <a href="https://hoshinoresorts.com/zh_tw/hotels/omo3sapporosusukino/" target="_blank" rel="noopener">OMO3 札幌博野</a> 商務旅館。他離博野鬧區非常近，而且價格實惠，所以也很推薦！</p><h3>Day4</h3><p>吃夜間麵包 -&gt; 中島公園慢跑下大雨 -&gt; 買登山包包 -&gt; 突襲北海道大學中央食堂吃午餐 -&gt; 喝咖啡 -&gt; 爬藻岩山 -&gt; 看藻岩山夜景 -&gt; 晚餐 <a href="https://www.bigfang.tw/blog/post/daruma-5dot5-susukino" target="_blank" rel="noopener">成吉思汗</a> -&gt; 買夜間麵包</p><p>早餐吃的夜間麵包是這間飯店推薦座落在飯店旁邊的小店，他的營業時間竟然是晚上 17:00 到凌晨四點，然後會幫每個麵包取人名很可愛</p><p>今天又鼓起精神去中島公園慢跑，這公園景色挺優美的，裡面有古蹟跟湖，風景不錯！只是回程的時候突然下大雨，只能很狼狽地回到飯店 XD</p><p>接著去逛了有名的戶外用品 <a href="https://maps.app.goo.gl/KWtXCydeVexeXKBc6" target="_blank" rel="noopener">秀岳莊</a>，買了一直很想買的小型登山包</p><p>在北海道大學吃完午餐吃後，就直接用新包包去爬藻岩山！原本以為很簡單，結果坡度其實滿陡的，我們大約花了一小時 15 分才到山頂，然後在山頂待到太陽下山欣賞夜景，最後搭纜車下山</p><p>晚餐吃有名的成吉思汗烤羊肉，的確是沒有什麼羊騷味！但價格頗高，又要排隊一陣子，如果下次再訪我可能會選擇別間試試</p><h3>Day5</h3><p>吃夜間麵包 -&gt; 逛狸小路 -&gt; 二條市場 -&gt; 午餐 <a href="https://g.co/kgs/BSJryJ9" target="_blank" rel="noopener">toriton</a> -&gt; 逛運動用品 -&gt; Sapporo 啤酒工廠 -&gt; 晚餐 OMO3 飯店烤玉米 -&gt; 清酒喝到飽 <a href="https://www.bigfang.tw/blog/post/wa-sakurairo-susukino" target="_blank" rel="noopener">櫻彩</a></p><p>今天很觀光客行程～ 狸小路像是專門買藥妝用的地方，二條市場看起來也都是觀光客專門店，Sapporo 啤酒工廠有點像是台灣的金車酒廠 XD</p><p>最值得一提的就是今天的餐點了吧！午餐的 toriton 真的很棒，很多在台灣吃不到的生魚片種類，價格又便宜！缺點是通常需要排隊，而且交通稍微不便，如果自駕的話會很適合去</p><p>在清酒喝到飽之前，我們先吃飯店賣的烤玉米墊胃 XD 但不得不說我第一次吃到這麼甜的玉米！我們兩個小鳥胃一人一根玉米之後就半飽了，準備好迎接人生第一次的清酒喝到飽</p><p><a href="https://www.bigfang.tw/blog/post/wa-sakurairo-susukino" target="_blank" rel="noopener">櫻彩</a> 裡面的座位似乎都是小包廂（是不是之前的客人都太失控？）他會提供每種酒的產地 / 種類（純米酒 / 純米吟釀 …） / 辛口度，非常專業。對我來說今晚真是喝得最過癮的一天！但老婆似乎有點喝到怕了 XD</p><h3>Day6</h3><p>租車被雷 -&gt; 去有名的休息站 -&gt; 去有名的豆腐店 -&gt; 去牧場 -&gt; check in -&gt; 泡湯 -&gt; 開車去湖對面吃烤肉 -&gt; 看洞爺湖煙火 -&gt; 晚上喝便利商店酒</p><p>在台灣就已經預約好租車，然後充滿信心的去租車地點，結果彷彿完全沒預約…店員看到訂單上的車種跟我預約的不同…連人名也不同（根本就找錯訂單了吧 = =）前前後後拿合約給我簽的時候名字欄位打錯兩次（而且一開始就提供護照給他了），從 10 點搞到 11 點才租到車，價格還比訂單上的貴了幾千日圓，感覺是運氣不好遇到超兩光店員 + 租車網的問題，我是透過 <a href="https://tc.tabirai.net/car/" target="_blank" rel="noopener">Tabirai</a> 租的，下次會選別的試試</p><p>今晚入住的飯店是 <a href="https://www.wehoteltoya.com/" target="_blank" rel="noopener">WE HOTEL TOYA</a>，不管是外觀還是內裝都是純木色系，給人非常有質感的感覺。此外每個房間跟大眾溫泉都面對洞爺湖湖景，每個房間還有配置一個小型木製溫泉，提供的浴衣也很漂亮，提供的早餐又好吃。雖然價格偏貴，但我覺得值得這個價錢！只是這個飯店不在洞爺湖主要的溫泉區，附近沒有商店 / 食物，會需要開車半小時才能到主要的街區，另外 10 點就要 check out 算是兩個小缺點。</p><p>洞爺湖在夏天的晚上會每天施放煙火，但施放地點在主要的溫泉區，所以我們先開車半小時到那附近吃完飯後接著欣賞。覺得比想像中精彩很多，原本以為每天施放應該是隨便放個幾發就沒了，結果竟然長達二十分鐘，而且有些煙火是在水面上施放，非常壯觀！</p><p>雖然飯店有酒吧，但看到那個價格…我決定去便利商店買幾瓶日本酒回房間喝比較划算，平均一瓶 200ml 大約 400 日圓，非常之超值！</p><h3>Day7</h3><p>泡湯 -&gt; 早餐(飯店提供) -&gt; checkout 前 10 分鐘泡房間溫泉 -&gt; 去有珠山走步道(白茫茫) -&gt; 室蘭 -&gt; 午餐（室蘭拉麵） -&gt; 室蘭八景其中三景 -&gt; 登別 -&gt; check in -&gt; 泡湯 -&gt; 開車去機場接朋友 -&gt; 泡湯 -&gt; 喝便利商店酒</p><p>原本沒注意到 10 點要退房，9:45 終於在房間準備好溫泉水的時候才被提醒 15 分鐘後要退房，只好硬是泡了 10 分鐘再起來準備</p><p>今天的天色是一片霧茫茫，早上泡溫泉看不太到洞爺湖，有珠山上也是沒什麼景色。接著去室蘭突然天氣非常好，總算是看到了一些海景，其實這裡的景色非常像台灣的北海岸 XD 但看到海心情還是挺舒暢的</p><p>晚上有個要從登別往返新千歲機場接從東京來會合的朋友的行程，其實比想像中快不少，單趟大約四十分鐘就到了，只是晚上開車因為視線較差注意力要保持集中稍微有點耗神，最後回到飯店再去泡溫泉補充元氣</p><p>今天入住的旅館是 <a href="https://takimotokan.co.jp/zh-hant/" target="_blank" rel="noopener">第一瀧本館</a>，我非常喜歡他們的大眾溫泉！場地非常大，有各種不同的泉水 / 溫度 / 室內外可以選擇，而且男湯有一大片落地窗在白天直接朝向地獄谷，景色很不錯又很氣派，雖然房間有點老舊感，但價格實惠我還是很推薦！</p><p>算了算今天竟然泡了四次湯 @@</p><h3>Day8</h3><p>泡湯 -&gt; 早餐（便利商店）-&gt; 地獄谷 -&gt; 午餐（天婦羅蕎麥麵）-&gt; 野鳥之森散步 -&gt; 札幌藝術之森 -&gt; check in -&gt; 還車 -&gt; 吃石狩鍋 -&gt; 喝便利商店酒</p><p>一早泡湯完吃完早餐就去飯店附近的地獄谷走走，這裡很像是放大版的陽明山小油坑，只是規模大很多，風景也好很多。</p><p>接著朝札幌出發，一路上去了兩個地方走走，一個是支笏湖溫泉區附近的野鳥之森，一個是札幌藝術之森，這兩處都被森林圍繞，充滿蟲鳴鳥叫非常悠閒，都是很適合散步的地方。順帶一提北海道真的生態維持良好，我們在野鳥之森竟然看到野生的鹿，開車的這三天也前後遇到三次鹿！</p><p>今天住的是 <a href="https://www.keioplaza.com/tw/chainhotel/index.html" target="_blank" rel="noopener">札幌京王飯店</a>，房間的景色很好，一邊可以看到鐵軌，一邊是綠油油的北海道大學，飯店早餐也提供非常多樣的選擇。只是我跟老婆還是有些小失望，因為早餐雖然多樣但沒有想像中好吃，畢竟要價也不斐，差不多的價格可以去住前面提到的 WE hotel（雖然地點不同好像不能這樣比就是了）</p><h3>Day9</h3><p>早餐(飯店 buffet) -&gt; 逛手工品的小店 -&gt; 喝咖啡 -&gt; 再訪手工品的小店 -&gt; 機場 -&gt; 午餐（白樺山莊拉麵）-&gt; 搭飛機</p><p>今天我們的 best friend 查好了兩個很酷的公寓，這兩個公寓裡面的每層樓都有一些房間是賣手工藝品的，完全是我跟老婆查不到的行程！到達第一個公寓就慘遭滑鐵盧，竟然週日公休，幸好第二個公寓的商店有開，其中有間賣手工銅錫藝品的店，有賣青蛙 / 熊 / 銀喉長尾山雀等等的鑰匙圈 / 擺飾等等。老闆娘非常熱情，是個熱愛熊的健談之人，那天我又剛好穿著 “北海道有熊喔！” 的可愛 T-shirt，因此他就滔滔不絕的講了跟熊有關的小知識（幸好 best friend 是日文翻譯），是我這趟旅程中印象最深刻的日本人，覺得都聽不懂有點可惜，甚至讓我有點想學日文了呢！</p><p>接著去喝咖啡，遇到一個呆呆的店員，來點餐完之後竟然記不得我們有點什麼，老闆站的比他還遠，一邊做咖啡還記得比他清楚，後來上咖啡也完全不記得誰點了什麼 XD 後來比較沒客人進來的時候他竟然很大方地坐在吧檯吃飯！感覺是個很友善的工作環境呢～</p><p>喝咖啡的途中，我下定決心要回去買剛剛的手工藝品，除了產品可愛之外，也覺得想幫熱情的老闆娘捧場一下。這次也是各種聊天，他還跟我們講說他們夫妻之後會去東京日本橋擺攤，期待跟我們的 best friend 蕭小姐在那裡碰面</p><p>在這之後就是跟 best friend 去機場一起買伴手禮 / 各自搭飛機回去結束這次的北海道之旅～</p>]]></content>
    
    
    <summary type="html">Hokaido Travel Notes</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>演講摘要 - The Many Meanings of Event-Driven Architecture</title>
    <link href="https://qoosuperman.github.io/article/2024-05-27-The%20Many%20Meanings%20of%20Event-Driven%20Architecture/"/>
    <id>https://qoosuperman.github.io/article/2024-05-27-The%20Many%20Meanings%20of%20Event-Driven%20Architecture/</id>
    <published>2024-05-27T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>不久前我看了一場關於事件驅動（event-driven）的 <a href="%5Bhttps://www.youtube.com/watch?v=STKCRSUsyP0%5D(https://www.youtube.com/watch?v=STKCRSUsyP0)">演講</a>，從中獲益良多，因此決定特別記錄下來。</p><p>演講者是Martin Fowler，他最為人所知的作品應該是《重構》（Refactoring）這本書。</p><p>Fowler提到，許多人跟他說他們正在使用事件驅動架構，但大家心中所理解的並不一致。他整理完之後，認為主要可以分為下列四種模式：</p><ol><li>事件通知（Event Notification）</li><li>攜帶狀態的事件傳遞（Event-carried state transfer）</li><li>事件溯源（Event sourcing）</li><li>命令查詢責任分離（CQRS）</li></ol><p>以下是對這些模式的說明：</p><h2>Event Notification</h2><p>這算是最常見的一種類型：單純利用事件來解耦合。舉例來說，在保險系統中，若需要更改地址，客戶管理系統（customer management ）就需要通知保險報價系統（insurance quoting），從而形成依賴關係。</p><p><img src="https://hackmd.io/_uploads/H1EGecEWA.png" alt="image"></p><p>採用 Event Notification 的作法後，流程變成了發布 / 訂閱模式，由客戶管理系統發布事件，保險報價系統訂閱這個事件。</p><p><img src="https://hackmd.io/_uploads/S1h3xvzbR.png" alt="image"></p><p>優點：能夠解耦信息的接收者和發送者<br>缺點：整體流程的行為較難追蹤</p><h3>Event vs Command</h3><p>講者還提到在事件系統中，有的人會用事件（events），有的人會用命令（commands），這兩者到底有什麼差異？</p><p>他認為，這兩者有微妙的區別，通常是取決於你對於這個東西的想法，如果這件事情發生了，而你不在乎他的結果，通常會使用 event 來命名（就像單純述說某件事情發生了），而如果這件事情發生，而你很在乎他，通常會取 command（就像你命令某人去做事情）</p><h2>Event-carried state transfer</h2><p>這是 event notification 的另一種形式，不過相對較少見。</p><p>有時，雖然保險報價系統（Insurance quoting）接收到了事件，但資料不夠充分，因此需要反問客戶管理系統（Customer Management）以取得額外資料。當然我們可以將所需資訊都放在事件中，但有時資訊過多不適合這樣處理。</p><p>為了不讓 Customer Management 增加額外的 loading，可以複製一份需要的資料（可能是獨立的資料庫）專門讓 Insurance quoting 去查詢<br><img src="https://hackmd.io/_uploads/r1mj_wMZR.png" alt="image"></p><p>而這個做法的缺點在於資料的一致性，因為複製過來的資料不一定是最即時的<br><img src="https://hackmd.io/_uploads/S1gTFvfbR.png" alt="image"></p><h2>Event sourcing</h2><p>事實上，許多軟體開發者都使用過基於事件溯源 (event-sourcing) 的工具，如 Git。</p><p>判斷是否為 event sourcing system 的關鍵在於，如果所有資料流失，只剩下 event log ，是不是可以根據 event log 回復你的所有資料，如果是的話他就是 event sourcing system。</p><p>優點：</p><ul><li>Audit</li><li>Debugging</li><li>Historic state</li><li>Alternative state</li><li>Memory image: 有了 event 之後，其實 application 運行可以不需要 persistent store，把所有的東西都在 memory 運行，可以讓 application 變得非常快，然後每天打一次 snapshot 紀錄狀態</li></ul><p>缺點：</p><ul><li>Unfamiliar</li><li>External systems：雖然系統內可以 replay，但如果打外部 API，現在重放可能跟兩個禮拜前打 API 的結果不同，可能需要考慮 partner replay event</li><li>Event schema：舊的事件模式仍然必須以某種方式與新版本的程式碼一起工作</li><li>Identifiers: 產生 identifier 給某個東西的時候也要特別小心，不要影響回放</li><li>Asynchrony: 異步處理對於人們的處理是很難的，而使用 event sourcing 不一定要搭配 Asynchronous 來使用，當有人抱怨每次要增加 feature 時要處理 write model 跟 read model，變成兩份工作時，這跟 event sourcing 無關，跟 Asynchornous 有關</li><li>versioning: 當有個一年前的 event，我想要回放他，還是可以 apply 的嗎？增加 versioning 也增加了整體的複雜度</li></ul><p>講者特別提到一點挺有趣的，在 Git 中，我們如果只看每個 commit 的改動，只能看到改變了什麼而無法知道為什麼要改，所以我們必須透過 commit message 得知意圖</p><p>同理，當我們在試圖儲存 event 的時候，也分成 external event / internal event，external event 充分展現了意圖，internal event 則表示這個 event 改變了什麼，他想討論在 event sourcing 中，需要儲存的 event 是哪一種，講者說他覺得大部分情況下應該同時儲存兩者，其中一種情境可以看下面範例</p><p>在下面的圖中，有個錯誤，實際上的價格是 32 而不是 33，但我們又難以去改這些 event，因為 output event 已經發送給其他系統做操作，會影響後續一系列的事件，因此陷入了 event 彼此糾纏而無法 replay 的窘境，他的建議是不要任何 business logic 放在這些跟其他系統溝通的 event 中，而解決這個問題的一種方式就是同時儲存 external 跟 internal events<br><img src="https://hackmd.io/_uploads/HyVVv0h70.png" alt="image"></p><h2>CQRS</h2><p>CQRS的主要概念在於分離讀取和寫入模型。</p><p>作者指出使用這種模式時需要謹慎，認為只有在某些特定情景下，這種模式才適合使用。強調應該清楚理解其優勢，確信需要這些優勢時才採用。</p><p>作者認為 CQRS 並不只是把資料轉換過放到另一個不同的 database 做查找（ex. 把資料轉換後用不同形式放到 big query 專門產生報表用資料），重點在於寫的模型不會被任何讀取操作使用到，這才是相對比較少見的</p><p><img src="https://hackmd.io/_uploads/HJ4tM_fW0.png" alt="image"></p><h3>IDDD 中的使用範例</h3><p>另外分享一下在《實踐領域驅動設計》（IDDD）裡面看到的範例。</p><p>在事件溯源系統中，想要獲取當前狀態時，可以通過快照加上部分事件回放來獲知。而在需要對這些物件進行搜索時，則是運用 CQRS 的 理想時機。每次事件發生時，最新狀態將寫入 Event store（圖中稱為 command store），同時也會有訂閱者更新 read model的數據，這樣一來就可以透過 read model 去做查詢並維持原本的 replay 機制。</p><p><img src="https://hackmd.io/_uploads/SksYmghxR.png" alt="image"></p><h2>心得</h2><p>之前從沒想過 Event Driven 還可以區分成這麼多不同類型，小到單純是寫程式的一種 pattern，大到整個系統會需要依賴於這些事件而存在。然而，並不存在所謂的 best practice，不同情景各有其最合適的方法。</p><p>感謝這個演講，真的讓我獲益良多，也令我期待在未來的不同情境中找到合適的實踐方式。</p>]]></content>
    
    
    <summary type="html">演講摘要 - The Many Meanings of Event-Driven Architecture</summary>
    
    
    
    
    <category term="Developer" scheme="https://qoosuperman.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>實現領域驅動設計(IDDD) 閱讀心得</title>
    <link href="https://qoosuperman.github.io/article/2024-05-16-%E5%AF%A6%E7%8F%BE%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88IDDD%20%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"/>
    <id>https://qoosuperman.github.io/article/2024-05-16-%E5%AF%A6%E7%8F%BE%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88IDDD%20%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/</id>
    <published>2024-05-16T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我花了一個月時間閱讀了一本書《Implementing Domain Driven Design》（簡稱IDDD）。由於封面是紅色，因此在DDD社群中，也有人稱為 “小紅書”。</p><p>原本打算寫書摘，但看了這系列的 <a href="https://ithelp.ithome.com.tw/users/20111997/ironman/2730" target="_blank" rel="noopener">鐵人賽文章</a> 後，發現內容寫得非常好，甚至結合了c lean architecture 的概念。我認為自己很難寫得比他更好，因此決定只紀錄自己的關鍵收穫和心得。</p><h2>Ubiquitous language(通用語言)</h2><p>DDD非常強調在團隊內使用通用語言溝通，這樣能避免 “每次工程師講話都聽不懂” 的情況，還能讓程式碼更貼近業務邏輯。最理想的情況下，團隊成員甚至能大致看懂程式碼的目的。</p><h2>Domain / Bounded Context</h2><p>Domain 和 Bounded Context 是書中的核心概念。Domain 即公司業務範圍，我們可以將這些業務拆分成多個 subdomain，而軟體就是要解決這些 subdomain 中在等待軟體解決的問題。我們會通過 bounded context 作為系統邊界設計多個系統，每個系統可能對應一個 subdomain，或同時解決多個 subdomain 的部分問題。</p><p>這部分的設計屬於戰略設計（Strategic Design），也就是設計大架構和方向。</p><h2>建模工具</h2><p>DDD 提供了各種建模工具，並明確定義它們的職責，包括：Entity / Value Object / Repository / Aggregate / Application Service / Domain Service / Domain Event。</p><p>這部分的設計屬於戰術設計（Tactical Design），也就是實際開始寫程式。</p><h2>Event Driven &amp; CQRS</h2><p>書中用 shell script 的命令範例來講解事件驅動的概念，讓我耳目一新並更加理解了事件驅動架構（Event Driven Architecture, EDA）。另外，書中提到，由於 Event Sourcing 系統難以從資料庫查詢所有需要顯示的數據，因此非常適合搭配 CQRS 來分離 Query Model 和 Command，這點也讓我有種豁然開朗的感覺。</p><h2>心得</h2><p>看完書的這幾天，不論是寫程式還是思考問題時，我彷彿被洗腦一般，都會忍不住用DDD的思維去思考，這代表我學到了很多東西吧！</p><p>雖然目前使用的 Rails 框架預設使用方式中，資料模型和領域模型被綁在一起，這部分若要效法 DDD，會需要額外花心力拆解。但其他如 value object 和分層結構的概念仍有很多可以應用。</p><p>同時，這本書詳細介紹了 Event Sourcing，我也因此查詢了 Event Driven Archiecture 中的各種不同類型，收穫非常豐富。</p><p>我相信很多人跟我一樣，在看完這本書後，對書中的概念仍有些模糊。因此我有額外與看過這本書的同事們進行交流討論，並參考了其他好心工程師在網路上分享的文章，才覺得自己對書中要傳達的知識有了更好的掌握。在此也特別感謝他們！</p>]]></content>
    
    
    <summary type="html">實現領域驅動設計(IDDD) 閱讀心得</summary>
    
    
    
    
    <category term="Developer" scheme="https://qoosuperman.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>學習如何學習 書摘</title>
    <link href="https://qoosuperman.github.io/article/2024-02-17-%E5%AD%B8%E7%BF%92%E5%A6%82%E4%BD%95%E5%AD%B8%E7%BF%92%20%E6%9B%B8%E6%91%98/"/>
    <id>https://qoosuperman.github.io/article/2024-02-17-%E5%AD%B8%E7%BF%92%E5%A6%82%E4%BD%95%E5%AD%B8%E7%BF%92%20%E6%9B%B8%E6%91%98/</id>
    <published>2024-02-17T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子聽到同事推薦這本書，所以看了並記錄一些我自己覺得重要的 takeaways</p><h2>圖文漫步</h2><p>在閱讀新的章節之前，先瀏覽這個章節的標題 / 粗體字 / 圖片，有個概念之後再開始閱讀</p><p>這會幫助你的大腦先有個概念，之後吸收知識更有效</p><p>也最好在閱讀的同時做筆記，紀錄重點 / 回答問題，也可以畫些東西增強記憶，避免無意識地閱讀</p><h2>專注模式 vs 發散模式</h2><p>人的大腦有兩種不同的工作模式： 專注模式 / 發散模式</p><p>專注模式表示你正在集中注意力，你會讓大腦的特定區域工作，至於是哪個區域則取決於正在做什麼事情，會根據做的事情而改變，可以想像你在嘗試某個新事物時，你必須先專心來打開大腦的這些區域</p><p>發散模式表示你可能正在溫和地使大腦的某些區域，這個模式幫助你在各種想法之間建立聯繫，創意 / 靈感幾乎都是發散模式中冒出來的</p><p>很多實驗證實，良好的學習必須在兩個不同模式中來回切換</p><h3>如何進入專注模式</h3><p>很簡單，只要把注意力集中到某件事情上面，專注模式就啟動了，但通常我們無法長時間處在專注模式中</p><h3>如何進入發散模式</h3><p>但我們注意力集中太久，無法專心，自動就會切換到發散模式</p><p>我們也可以透過散步 / 看著窗外 / 沖澡，進入發散模式，睡覺也是，而睡覺算是終極的發散模式</p><p>除了上述方式，專注於其他事情也可以讓我們對原本關注的事情進入發散模式，像是解數學題解到一半無法突破，轉而去學習地理，或者學習到一半去擁抱旁邊的狗，都可能讓我們在原本學習的項目上有所突破</p><h3>模式切換的想像：彈珠臺</h3><p>可以想像成有兩個彈珠台，一個在上一個在下，彈珠在上面的彈珠台表示你正在專注模式，在下面的彈珠台表示你正在發散模式，當你不使用專注模式彈珠台的檔版，球會掉下來跑到發散模式的彈珠台</p><p>人要長時間在專注模式中不容易，就像我們不可能永遠控制著彈珠台的擋板不讓彈珠滾落</p><p>而患有 ADHD 的兒童，他們的注意力更容易渙散，可以想像成他們的專注力彈珠台有額外的幾個洞，彈珠更容易掉下來，所以他們必須更勤快的練習使用擋板不讓彈珠掉下來，實際的方式包括：多參與練習 / 學習時同時書寫 / 參與問答</p><h3>困境</h3><p>學習的時候有兩種陷入困境的模式</p><ol><li>一開始就沒弄懂<br>這時候從專注模式進入發散模式不會有好處，因為你還沒把知識 “加載” 到專注模式中</li><li>已經認真學習，但練習某個動作 / 解題，無論如何就是做不出來<br>這時候可以休息一下，讓發散模式幫助學習，大部分情況下，抓個 5-10 分鐘的休息時間是比較恰當的</li></ol><h2>戰勝拖延</h2><p>一旦開始執行不想接受的任務，痛苦大約會在 20 分鐘後消失，所以訣竅是不要拖延工作，立刻開始執行</p><p>可以用番茄鐘來幫助你切換模式</p><ol><li>避開所以會分散注意力的事物，然後專心 25 分鐘，在這過程中專注於某個任務，除非它完成了才能繼續下一個</li><li>25 分鐘之後，獎勵自己，做喜歡的事情 5~10 分鐘</li></ol><p>如果過了 25 分鐘還想繼續工作，那就繼續工作！可以沈浸在任務中是一件好事</p><h2>主動回憶</h2><p>在學習過程中，學習一個段落之後，可以把視線轉向別處，看看能回憶起什麼重要的內容</p><p>可以不用在書本的每頁都這樣做，但如果在重要的地方這樣做，對於學習很有幫助</p><h2>神經元跟大腦連結</h2><p>大腦裡有很多神經元，他們很小但可以很長，甚至可能比手臂還要長</p><p>把細胞核想像成頭的話，他們頭上有個頭冠，這是軸突，頭的下面有很多隻腳，這是樹突，樹突上面有很多突起，叫做樹突棘</p><p>一個神經元會透過軸突向另一個神經元的樹突上的樹突棘透過微小的電流傳遞訊號<br><img src="https://hackmd.io/_uploads/SJ4Dth25a.png" alt="圖片"></p><p>學習新事物的時候，神經元彼此之間會先形成弱連接（接下來我們會稱為大腦連結），但反覆練習之後，參與的神經元數量會增加，讓這個神經路徑變得更寬更好走，如此一來大腦連結就變得越來越強大</p><h2>睡眠</h2><p>在我們白天學習的過程中，神經元會產生一些隆起（專注的學習跟主動回憶都可以更刺激這些隆起的形成），而他們真正快速生長成為樹突棘的過程主要卻是發生在睡眠中</p><p>睡眠中大腦會演練白天學到的東西，讓信號反覆傳過同一組神經元，這種行為似乎可以讓樹突棘變得更大</p><p>但同時在睡覺的時候，沒有在用的樹突棘也會縮小甚至消失，因此剛學習的知識如果不加以練習，也是很容易被清除的</p><p>也因為以上的這些機制，間隔安排學習時間的成效往往比填鴨式教育的學習效果好上許多</p><h2>書包與儲藏櫃跟注意力章魚</h2><p>想像你有個書包跟一個儲藏櫃</p><p>書包跟儲藏櫃相比小很多，沒辦法攜帶很多東西，但這也是個好處因為你要帶著他到處走</p><p>儲藏櫃則是很大，但你要拿東西則要走一段距離，而且東西放太多的時候很難找到你要的東西</p><p>對比記憶的話，背包代表你的短期記憶，儲藏櫃代表你的長期記憶</p><p>可以想像你的短期記憶區域裡有個章魚幫你處理記憶短暫記憶，而她有四個觸手，代表一次最多只能記四個東西，再多就會記不住了，而每個人的情況不同，有的人腦中的章魚可能有更多觸手，或者有的人記住的東西可以比較久不會忘記</p><h3>儲藏櫃</h3><p>人的長期記憶就像是儲藏櫃，可以想像櫃子裡面貼了一些照片，同時有一條牙膏</p><p>如果要儲存一個圖像，就像直接把照片貼在儲藏櫃上非常簡單，但如果要儲存一個事實，像是戰爭發生的年份，就像是把東西塞進牙膏一樣困難</p><p>正是因為如此，人在學習的時候，透過隱喻可以比較快的吸收知識，因為這可以讓我們透過已經熟悉的東西來了解不熟悉的內容，當我們更了解細節時，有時候原本的隱喻就無法很好解釋，這時候可以果斷把舊的拋開，去找一個比較適合的新隱喻</p><p>記憶力世界冠軍分享了一些加強記憶的訣竅：</p><ol><li>專注</li><li>練習</li><li>想像畫面，如果畫面中添加動作會更容易記得住</li><li>把這個訊息跟已經知道的事情連結，例如把某個剛認識的人跟自己一個已經熟悉的人做連結</li><li>主動回憶，像是英文學習卡片就很有用</li></ol><p>除此之外也有些行動可以幫助記東西</p><ol><li>使用歌曲</li><li>使用隱喻</li><li>做筆記</li><li>想像自己就是正在試圖理解的那個東西</li><li>分享知識，並教別人（像是寫程式的時候一邊跟塑膠鴨子解釋為何這樣做）</li></ol><h3>注意力章魚與打腦連結</h3><p>當我們完整掌握了一個概念 / 知識的時候，一個大腦連結就會在長期記憶中形成，此後當我們需要用到類似的知識，腦中的章魚只需要一個觸手就可以把這整條知識拉到短期記憶中，同時章魚還有其他三個觸手是空著的，可以用來處理其他的訊息</p><p>雖然章魚只有四個觸手，但大腦連接本身可以跟其他的大腦連接拼湊起來，這樣也只需要章魚的一個觸手就拉出全部的知識，也因此專家們才能處理大量訊息並且回答複雜的問題</p><p>為了達到上面說的效果，要先創造一個大腦連接，因此首先必須要不斷地理解跟練習，像是第一次學習倒車的時候，因為還沒有任何的大腦連接，所以章魚必須很忙碌的工作來處理倒車，一旦這個連接完成了，只需要調用這個連接組即可</p><h3>避免分心</h3><p>當分心的時候，可以想像你腦中的章魚有一個觸手被剝奪了，儘管你可能沒有意識到，他必須放下原本抓住的大腦連接，等真正又要處理事情的時候再把連接抓回來，這樣做很辛苦，因此當我們在專注學習時要避免 “任務切換” 和 “分心”</p><h2>海馬體</h2><p>每天都會有新的神經元在海馬體內誕生，如果我們沒有學到任何東西，他們出生後不久就會消失，反之則會持續存在，讓我們夠記住，因此海馬體是記憶的其中一個關鍵</p><p>在睡眠時，學到的訊息會從海馬體的神經元傳遞到大腦皮質的神經元中，大腦皮質的神經可以視為我們長期記憶的大本營</p><p>因此睡眠有很多作用，除了先前講的會建立新的突觸之外，還可以清空海馬體，為新的學習騰出空間</p><p>研究發現，運動可以幫助新生的神經元生長，長出更多的突觸！還可以刺激生成一些化學物質像是血清素跟多巴安，他們有助於我們產生新的想法</p><p>同樣食物也會對神經元的生長有影響，多的水果跟蔬菜會有正面的幫助，同時也要避免加工食品</p><h2>有效建立大腦連結</h2><p>我們創建一組完整大腦連結的過程，就像在拼一幅拼圖</p><p>當連結夠多的時候，拼圖就會越來越簡單，慢慢會開始看到這個拼圖的全貌，就算有些小的沒拚進去，你還是可以大概知道長什麼樣子</p><p>但如果我們不練習這些新形成的大腦連接，這些拼圖會慢慢退色，整個拼圖慢慢的更難拼湊起來</p><p>這時候如何著手建立一個大腦連接組就顯得非常重要</p><h3>刻意練習</h3><p>當練習夠多之後，就可以建立起穩固的大腦連接，在這之後練習會變得容易，當如果你反覆練習已經會的東西，不能鼓勵新的樹突棘隆起，這樣即是所謂的惰性學習</p><p>應該避免惰性學習，把時間跟注意力放在更難的東西上，這叫做刻意練習，刻意練習可以讓你更快成為任何你正在研究的領域的專家</p><h3>交叉學習</h3><p>交叉學習則是有關靈活性，意味著練習你要學習的事物的不同方面（ex. 足球射門有各種不同的技巧）</p><p>當學習新東西的時候，回去複習舊的東西，則可以讓我們用不同的角度來思考以前學過的東西</p><h3>要建立大腦連結的步驟</h3><ul><li>專注</li><li>積極練習</li></ul><p>不管做什麼事情，要有效建立大腦連結，第一件事情絕對是專注，另外必須每天練習你的新技能，持續一段時間並確保每天都睡得好，以建立強壯的大腦連接組</p><p>同時要提升自己正在做的事情，練習不同的技巧，並做交叉練習</p><h2>檢視自己的學習狀況</h2><p>每個人的學習狀況都不盡相同，但能確定的是只有自己最清楚</p><p>像是每個人在學習的時候有沒有聽音樂狀況是不同的，連研究者也不確定，所以每個人要最清楚自己的學習狀況，你可以在學習完之後跟朋友聊聊，多觀察自己在各種情況下的學習狀況</p><p>自己反思</p><ul><li>晚上睡好之後，隔天白天是否表現更好</li><li>運動完之後學習是不是效率更好</li><li>學習時旁邊有手機是不是會分心</li><li>不聽音樂是否學習更有效率</li></ul><p>另外，經常變換學習場所是有幫助的，你如果平常都只在圖書館學幾何，那這組大腦連接上會沾附一些圖書館的氣息，但考試的地點切換到教室之後，沒有圖書館的氣味來引導，可能讓你考幾何的時候結果比較差</p><p>因此可以在不同地方學習，讓你的大腦習慣在長期記憶裡面找東西，而不去依賴上面對於特定場所的味道</p><p>大家雖然有偏好喜歡用特定的感官在學習東西（聽覺 / 嗅覺 / 視覺），但在學習任何東西的時候，要努力利用所有感官，做多感官學習，是很多研究認為最有效的學習方法</p><p>備註：有一件事情可以幫助睡得更好，就是把明天要做的事情制定一份任務清單，可以幫你把工作項目從記憶中釋放出來</p><p>以下還有一些改善學習狀況的小技巧：</p><h3>睡眠消毒</h3><p>當我們醒著的時候，會在大腦中產生有毒物質，當我們入睡的時候，腦細胞會收縮，有毒物質則會在細胞縫隙中被沖走</p><p>如果睡眠不足，則沒有時間清除所有毒素，起床後會昏昏沈沈，無法清晰思考，同時神經元也無法長出新的突觸</p><h2>先吃青蛙</h2><p>學習時，先去對付困難的事情，陷入困境就休息一下，讓你的發散模式為你工作</p><h2>制定終止時間</h2><p>如果可以為每天的學習設定一個中止時間，會很有幫助，也會降低壓力水平</p><h2>有關學習的一些驚喜</h2><p>家長常常不喜歡小孩玩遊戲，但有些遊戲可以加強人的某些方面能力，比方說動作遊戲就可以訓練人的專注力跟注意力，但也不應該成癮，適時的休息還有學習其他方面的能力可以讓我們學習的表現更好</p><p>當我們專精在某一技能時，只要我們學一些截然不同的東西，都可能讓我們在專精的這方面做得更好，否則我們容易在這方面無法輕易做出改變，導致思維不那麼靈活</p><h3>手寫筆記</h3><p>手寫筆記的效果比打字的筆記效果更好，因為當你寫的時候同時必須思考，作者建議在筆記上畫出一條線，分隔出 2/3 跟 1/3 的區塊，最初的筆記寫在 2/3 的區塊，複習的時候把重點寫在 1/3 的區塊</p><h3>短期記憶差</h3><p>短期記憶差的人的學習效果有時會比短期記憶好的人更好</p><p>可以想像有好的短期記憶的人，他們腦袋裡的章魚有更多的觸手，可以記住很多東西</p><p>但是短期記憶差的人，章魚的觸手更少，因此就要更努力的幫重要知識建立大腦連接，這種人沒有夠多觸手記住很多想法，所以要想辦法簡化知識並把他們彼此連接起來</p><p>同時短期記憶差的人常常會有想法從腦中溜走，但研究顯示這種時候會有另一個想法冒出來，因此反而會更有創造力，這種現象在有過動情形的人身上特別明顯</p><h2>有關考試</h2><p>考試是幫助你學習的最好方式之一，因為在考試中我們會努力回憶我們對某個主題知道的所有細節，而其實前面提到的主動回憶九算是對自己進行的一種小小考試</p><p>作者建議拿到考卷之後，先瀏覽一次全部的內容，並從最難的其中一題開始做，直到覺得卡住了，那就可以先去解別題，這樣做可以讓發散模式在背後幫忙想這個困難的問題</p><p>如果考試的時候感覺到非常有壓力，那在學習的過程中一邊進行回憶練習可能會幫助你</p><p>當人們在考試中的時候，會有各種身體上的改變，比方說容易出汗，心跳加速等等，但是這些壓力通常可以讓人在考試中表現更好，如果真的太緊張可以練習深呼吸緩解情緒</p><h2>總結</h2><p>當你可以找到積極的理由讓你對學習感興趣，而不是為了逃避懲罰時，效果往往更好</p><ol><li>專注模式跟發散模式都要加以利用</li><li>利用練習 / 重複跟回憶來建立大腦連接組</li><li>交叉學習：不要一味反覆練習基本技巧，要在不同技巧間來回切換</li><li>間隔安排你的學習，讓新突觸有形成的時間</li><li>多運動，不只能滋養你的神經元，還可以刺激長出更強壯的突觸</li><li>學習後進行主動回憶或者教別人</li><li>用有趣的圖片跟隱喻來加快學習速度</li><li>用番茄鐘的技巧來間歇的專注跟獎勵自己</li><li>先做困難的任務，中間可以休息一下讓發散模式幫助你</li><li>在課堂之外，積極尋找學習方法，像是加入某個學習組織</li><li>跟朋友一起學習，而不是跟他們聊天</li></ol><p>應該要避免的行為：</p><ol><li>睡眠不足</li><li>被動閱讀（要看完之後主動回憶）</li><li>單純在書本上畫線（應該要做筆記並且思考）</li><li>偷看答案欺騙自己已經理解</li><li>填鴨式學習</li><li>分心</li><li>惰性學習</li><li>不弄清楚沒理解的知識點</li></ol><p>強大閱讀效果的三大步驟：</p><ol><li>圖文漫步</li><li>仔細閱讀</li><li>主動回憶</li></ol>]]></content>
    
    
    <summary type="html">學習如何學習 書摘</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>管控不如預期 書摘</title>
    <link href="https://qoosuperman.github.io/article/2024-01-16-%E7%AE%A1%E6%8E%A7%E4%B8%8D%E5%A6%82%E9%A0%90%E6%9C%9F%20%E6%9B%B8%E6%91%98/"/>
    <id>https://qoosuperman.github.io/article/2024-01-16-%E7%AE%A1%E6%8E%A7%E4%B8%8D%E5%A6%82%E9%A0%90%E6%9C%9F%20%E6%9B%B8%E6%91%98/</id>
    <published>2024-01-16T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>近兩三年來，我看的書都跟 coding 相關，好像很久沒看一些主題比較軟的書，剛好前陣子同事在賣二手書，就買了幾本準備來看</p><p>其中一本是 “成功最關鍵的事-管控不如預期”，也就是今天要分享的這本書，看完之後，我覺得是一本對於擬定目標並制定計劃執行非常有用的指南，還滿推薦閱讀的，同時看完也會有 “別人也太認真了吧，自己也要加把勁！！！” 的熱血感（當然也可能只有我有這種感覺）</p><p>以下會記錄一些我自己覺得重要的 takeaways</p><h1>對計畫的三個誤解</h1><ul><li>很會安排的人懂的去把任務拆解，讓每個步驟都在最簡單的狀況下完成，同時也減少遲疑 / 煩惱的時間</li><li>多數人在安排事情時往往過於樂觀，這時可以嘗試<ol><li>找一個自己熟識的人，請他預估自己所需時間，這個人必須是你做錯事時會提醒你的人，需要好到這樣的程度</li><li>把自己做事情的時間詳細記錄下來</li></ol></li><li>一個時段只專注於一個任務，多工會讓人覺得自己完成很多事情，但大多會是沒能留下成就感的工作</li><li>多數人能發揮專注力的時段是在早上起床後到中午為止，所以可以多把握這段時間，下午改成比較單純的作業</li><li>計劃時沒考慮一些會遇到的挫折，最後導致安排失敗，會突然喪失鬥志導致自我放棄，這就是 “The What-The-Hell Effect”，這樣的話可以嘗試安排放假日，比例上可以先抓 15%，大約是兩週一次的頻率</li></ul><h1>正確計畫的科學原則</h1><p>MAC 目標設定法是作者目前覺得最有效的目標設定方法</p><p>M = Measurable，把目標數字化<br>A = Actionable，行動可行性<br>C = Completent，目標達成後是否符合自己價值觀</p><p>比方說目標是想要交女朋友<br>M: 設定在某個日期前，要交到女朋友<br>A: 要在期限前交到女朋友，需要做哪些行動，比方說登陸交友網站 / 請人介紹<br>C: 交女朋友真的是自己期待的事情嗎？</p><p>因為人是感性的動物，所以最後一項非常重要，前兩項可以幫助你實際朝目標前進，而最後一項則是讓你判斷是不是真的要去執行</p><h1>讓計畫不失敗的技巧</h1><h2>if then 原則</h2><p>這可以用在幫自己訂立一些改善效率的原則，像是 if 開始看 SNS，then 只能滑五分鐘後就要繼續工作</p><p>也可以用在訂定目標的時候，事先想到一些糟糕的情況，先想好如何應對</p><p>ex. 目標是培養每天學英文的習慣，想像什麼情況會讓計畫沒辦法正常實行：</p><ul><li>工作忙碌導致睡前沒時間學英文</li><li>推不掉的酒局，回家後無法專注<br>接著就為這兩種情況擬定 if then 條件</li><li>if 午夜才回家，就快點睡隔天早上唸書</li><li>if 要去應酬，就應提前唸英文</li></ul><h2>把行動過程視覺化</h2><p>設定目標之後，應該要先想像每天會怎麼去完成，這樣才比較有可能去執行</p><p>以作者為例，他想要培養每天運動的習慣，他會想像</p><ol><li>每天早上起床立刻踏上踏步機</li><li>一邊踩踏步機，同時把書翻開，持續 25 分鐘</li><li>踩完踏步機，書也看完了</li></ol><h2>把計畫倒推排定時程</h2><p>多數人在制定計畫的時候都會以現在的時間點往前排定計畫表</p><p>這種方式很容易因為當下有其他事情，覺得這件重要的事情還有幾個月，因此先做當下的事情，導致行程拖延</p><p>所以應該要從結果往回推，ex. 8月要報告，所以 7 月要先整理好報告，為了整理好報告， 6 月要先完成市調作業等等</p><h2>輔助計畫</h2><p>常常會有要做一件事情，但有在外在因素影響導致不能做的時候，可以善用輔助計畫的效果，讓什麼都不做的日子不見</p><p>比方說如果規定&quot;自己每天要跑步 30 分鐘&quot;，這樣的計畫方式會讓人心裡很沈重，因為可能會有 “今天身體狀況不好” / “今天外面下雨” 等等外在因素，所以最好改成：“一天跑 30 分鐘或是 15 分鐘的拉筋，又或是 30 分鐘的伸展訓練”</p><h1>行事曆</h1><p>作者認為 “行事曆沒有空檔的人不會成長”</p><p>努力讓自己的行事曆生出空檔，當突然想跳戰新事物時，立刻用這段時間付諸行動，如此才會進步</p><p>在使用行事曆時，建議把每天會做的事情通通寫下，並預測行動所花費的時間，可以把這件事情希望達成的目標也寫下來，這樣日後比較好審視並做反省</p><h1>其他</h1><h2>避免會議浪費時間</h2><p>任何人都可以隨意發表意見的話題，基本上都會脫離本質性的討論，這是一種時間的浪費</p><p>ex. 原子爐建設 / 高速高路建設這種重要的議題，發言者少但會慎重的進行討論，但該不該設置腳踏車放置處這種輕鬆的議題，就會很多人跳出來討論顏色 / 材質等等，但鮮少會有人提出 “究竟設置腳踏車放置處是否是個好的決定” 這種討論</p><p>可以透過這些方法縮短會議時間：</p><ol><li>事前共同決定議題</li><li>事前決定會議幾點結束</li><li>事前決定會議目標，這個目標達成會議就結束</li></ol><h2>休假技巧</h2><p>對於休假，有一項研究發現對於放假不擬定計畫，隨便打發的人，幸福感比較低，但如果有人訂了計畫 “這週末要在家無所事事” 再去執行，雖然他一樣是在家無所事事，但他的幸福感比較高，由此可見依照自己決定的步調來生活的人幸福感較高</p><p>研究者認為幸福感會增加，且持續的休假方式，三個 C 非常重要：</p><ol><li>Challenge 挑戰</li><li>Controllability 可控制性</li><li>Carefully Planning 周密的計畫</li></ol><p>挑戰的重點在於這件事情對於你來說是新鮮的，不用很困難，像是挑戰第一次做菜 / 變換家裡佈置 / 打掃除都算是挑戰的一種</p><p>但執行的同時要記得不要把時間表排得太密造成自己的壓力</p><h1>心得</h1><p>在看這本書之前，發現其實有些書中建議的做法，不知不覺中自己已經在使用了，像是會想辦法讓會議時間縮短 / 盡量把一些會做的事情都放上行事曆，但鮮少會想到要把這些改善效率的方法列舉下來，覺得這本書提供的一些建議都是未來很不錯的執行方向</p><p>當然書中還是有些作法對我來說是行不通的，像是作者推薦的番茄鐘工作法，像這種建議我就會嘗試過後行不通果斷放棄，畢竟每個人都是不同的個體，一定都是有些方法有效有的無效，反正就是不斷嘗試不斷精進就是了！</p>]]></content>
    
    
    <summary type="html">管控不如預期 書摘</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Retrospect And Prospect of 2024</title>
    <link href="https://qoosuperman.github.io/article/2024-01-01-Retrospect_And_Prospect_of_2024/"/>
    <id>https://qoosuperman.github.io/article/2024-01-01-Retrospect_And_Prospect_of_2024/</id>
    <published>2024-01-07T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<p>今年跟前面剛轉職的兩三年來說，算是比較不同的一年。</p><p>過去會很容易資訊焦慮，會強迫自己不能太過懶散，需要主動吸收新知 &amp; 持續學習不間斷。但自從下半年以來，一方面可能工作上的事情略微繁重，下班後已經沒有什麼精力，另一方面可能也是這種緊繃的心態持續太久，覺得自己需要適度的放鬆一下。</p><p>結果就是，在這下半年中，不管是跟朋友相處，或是打電動的時間都有大幅的增加～這樣休息帶來的好心情讓我覺得似乎已經準備好面對 2024 了！</p><p>以下條列回顧一下 2023 玩的遊戲 / 目標 / 看過的課程與書籍 / 值得紀錄的事情，並列出 2024 目標</p><h2>回顧 2022 的目標</h2><ul><li>[v] 工作更上手<br>只能說，自認為應該算是滿上手的了吧。</li><li>[ ] 保持學習熱忱<br>算是半完成，前半年還是很有動力學習一些東西，但後來慢慢沒有辦法持續。</li><li>[ ] 再更多喝水 &amp; 再更多的運動習慣<br>算是半完成，自從我買了一個超大水壺放在辦公室之後，喝水就明顯有幫助，但運動方面還是有待加強，可能需要固定的運動群體來讓自己有比較強烈的動機。</li><li>[v] 比過去的自己更不拖延<br>這點自認為有達到，覺得我後來的半年執行每週回顧的動作又幫助到我比較不拖延，後面會再細講。</li></ul><h2>Games</h2><p>今年玩的遊戲：</p><ol><li>潛水員戴夫</li><li>怪獸列車</li><li>博德之門 3</li><li>薩爾達傳說 2</li></ol><p>今年玩的遊戲中，最喜歡的是博德之門 3，再來是潛水員戴夫，這兩款遊戲都讓我體會到開發者對於遊戲滿滿的愛。</p><p>潛水員戴夫是個像素風格的捕魚遊戲，早上要去海裡潛水打魚，晚上又要去壽司店幫忙上菜或者倒飲料。這款遊戲不管是劇情還是遊戲方式都很胡鬧，裡面的遊戲方式包括彈幕射擊 / 動作遊戲 / 料理遊戲，感覺是開發者想得到的遊戲方式都放進去，劇情方面也是很天馬行空，但就不劇透了，總之這款遊戲真心推薦。</p><p>博德之門則是我看過自由度最高的遊戲，遊戲裡面你看得到每個物件幾乎都可以互動，而且劇情的分支也是多到難以想像。這些自由度是我以前完全沒辦法想像的，身為工程師我更無法想像做這款遊戲的工程師為了這樣的自由度要修掉多少 bug，真的是心中非常有愛的團隊才做得出來吧！？他可能不是個大家一眼就會喜歡的遊戲，畫風也沒有說非常精緻，但沈浸的感覺對我來說是數一數二，劇本長度也非常有誠意，完全是精神時光屋一般的存在。</p><h2>課程與書籍</h2><ul><li><p>Prompt Engineering for ChatGPT<br>這線上課程非常推薦！在目前這年代如何跟 AI 溝通應該算是基礎能力的一種了，而這堂課就是在教你一些跟 AI 溝通的模式，幫助更快得到需要的結果。</p></li><li><p>Rebuilding Rails<br>這本書的心得在前面講過，看完之後是覺得沒有非常推薦閱讀，但初學 Rails 的人可以從裡面更了解 Rails 一些～</p></li></ul><p>今年比較多著重在寫 code / 研究工作相關的 project 上面，所以比較偏零散地閱讀，接下來的這一年應該會開始回歸讀一些軟性的書籍，希望可以同時增進自己的軟實力。</p><h2>值得紀錄的事情</h2><h3>養成每週回顧的習慣</h3><p>大概在半年前開始常常覺得沒有很確定下一週的計畫讓人心煩，又或者沒注意到某個事件即將發生，突然在隔天行事曆跑出來讓我覺得不知所措。<br>因此最近半年，我幾乎都會在每週做個回顧，裡面包括每週例行要做的一些事項，像是整理桌面 / 整理下週的代辦事項 / 紀錄過去一周完成了哪些事情等等。<br>執行了約半年，我覺得在每週的剛開始就知道下週的目標對我來說滿有幫助的！未來希望可以持續下去。</p><h3>跟老婆去了瑞士</h3><p>老婆因為工作的關係，幾乎每年都會去瑞士出差，他也一直很希望可以跟我到瑞士旅遊，終於我們在今年實現了這個願望！我們初次體驗了滑翔傘 / 世界知名的冰河列車，又可以做我們最愛的健行活動，同時看著跟台灣截然不同的山景。</p><p>最近朋友分享了 “記憶股息” 概念，覺得非常有道理，直接在這邊引述他的話:</p><blockquote><p>與股票股息相似，指的是當越早在人生中創造越多的回憶，這些回憶就會在往後提供快樂的情緒。例如，你可能曾經跟朋友到許多地方旅行，而這些回憶就會藏在你的腦海裡。日常中當你看見一些旅行片段、聽到朋友提及這段體驗時，就會勾起你當初的回憶，讓你感到快樂與溫馨。而這些「因回憶而收穫的快樂」，就是記憶股息的體現。</p></blockquote><p>看到這段話，讓我想起之前跟老婆蜜月去秘魯跟這次去瑞士兩段旅程，雖然這段日子都只在生命中佔據少少的一部分，但卻常常在我的心中浮現這些日子的回憶，以後一定要跟老婆再去更多地方！</p><h3>規模堪比求婚之驚喜派對</h3><p>今年年底幫某位壽星規劃了史上最盛大的驚喜派對，現在想想也是覺得非常瘋狂。因為知道這個壽星每年生日都會跟他的國中同學一起過，所以就私下去聯絡這位國中同學，並在壽星出國期間舉辦了秘密會議。生日當天還有三波驚喜（驚嚇？），分別是剛進來的拉砲 / 後來玩遊戲才有的生日禮物 / 晚上 12 點後送上我們一行人花了快半年接龍完成的小說精裝本。經過這次才知道原來生日派對可以辦到這樣的規模，因為非常花時間與精力，所以也奉勸各位不要輕易嘗試。</p><h3>弄牙齒</h3><p>今年也花了超多時間去看牙醫 &amp; 弄牙齒，以前刷牙習慣不好導致蛀牙一堆，導致現在看牙非常之痛苦，每次都要忍受牙醫器械發出的高頻聲音真的很不舒服，看完牙之後也會呈現精神耗弱的狀態，比較難繼續做其他事情。今年開始有改變刷牙習慣 &amp; 開始使用電動牙刷，希望未來可以不用再遭受這種痛苦。</p><p>今年還有其他很多值得紀錄的事情，我就列在下面：</p><ul><li>跟哥一起去看了小時候最愛的灌籃高手電影版</li><li>跟長輩一起去了東京</li><li>絞盡腦汁想了老婆生日驚喜的解謎遊戲</li><li>看了 Mr.Big 的告別演唱會</li><li>爬了玉山</li><li>規劃了 server 架構的轉移(工作上)</li></ul><h2>2024 的目標</h2><ul><li>一座百岳</li><li>培養學習熱忱</li><li>培養運動習慣</li><li>上木工的線上課程，並自己做一個傢俱</li><li>跟朋友維繫感情</li></ul>]]></content>
    
    
    <summary type="html">Retrospect And Prospect of 2024</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>如何撰寫前期規劃技術文件</title>
    <link href="https://qoosuperman.github.io/article/2023-10-24-Write_Technical_document/"/>
    <id>https://qoosuperman.github.io/article/2023-10-24-Write_Technical_document/</id>
    <published>2023-10-24T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<h2>Introduction</h2><p>已經在 Hahow 工作了一段時間，在這段期間中，除了持續精進程式設計之外，還逐漸學習了一項新技能：編寫前期規劃的技術文件。</p><p>並不是每個開發團隊在開始開發之前都會進行這個步驟，但我認為這是一個相當不錯的流程。</p><p>通過一份文件，開發團隊可以迅速對齊對功能實現的方向和預期要完成的任務，這樣可以避免走錯大方向，而在 Code Review 階段也能省下許多討論時間。</p><p>寫這篇文章的目的是為了記錄一下這種技術文件通常會包含哪些內容，並分享一些我的見解。</p><p>我認為一份完整的技術文件通常會包括以下幾個部分：</p><ul><li>Title</li><li>Metadata</li><li>Changelog(optional)</li><li>Glossory(optional)</li><li>Solutions</li><li>Q&amp;A or Discussions</li><li>Missions</li></ul><p>以下就來介紹一下他們：</p><h2>Title</h2><p>標題是大家能否快速找到文件的關鍵，格式通常如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[團隊名稱] &lt;這份文件的功能&gt;技術文件</span><br></pre></td></tr></table></figure><p>在 &lt;這份文件的功能&gt; 這個部分，應該包含大家可能會用來搜索的關鍵字，比方說實體活動的功能，有時候會被簡稱為 O2O，那標題應該命名為 <code>企業活動（O2O）技術文件</code></p><h2>Metadata</h2><p>這裡簡單列出文件的基本資訊，有點像打開電腦資料夾後，檢視檔案清單的那些選項。具體要列出哪些內容，可以根據團隊的需求進行調整，但通常至少應該包含作者的名字，以我們團隊來說通常會包括下面這些項目：</p><ul><li>Authors</li><li>Team</li><li>Reviewers</li><li>Created at</li><li>Links(Tickets link, Design Draft link, frontend doc link… etc)</li></ul><h2>Changelog</h2><p>這部分通常以表格形式呈現。有時，一個功能可能需要時隔相當長一段時間後再次開發，透過 Changelog，我們可以了解哪些部分是之前的人寫的，哪些是新添加的。</p><p>但如果功能較小，或者有其他理由認為不需要這些資訊，則可以選擇省略這一部分。</p><p>以下是一個範例：</p><table><thead><tr><th>Date</th><th>Description</th></tr></thead><tbody><tr><td>2023/1/19</td><td>起草</td></tr><tr><td>2023/2/23</td><td>新增搬遷 RDS 計畫</td></tr></tbody></table><h2>Glossory</h2><p>有時在規劃一個大家不太熟悉的功能時，需要有一個類似辭典的段落，以便讓團隊成員熟悉一些必要的專業術語，然後再繼續閱讀。</p><p>除此之外，使用中文名詞溝通的時候，有時會遇到每個人對於這個中文名詞指涉的內容的想法都不一樣的情況，也可以透過這個段落拉齊大家的名詞共識。</p><p>以下是一個範例：</p><table><thead><tr><th>Terms</th><th>Description</th></tr></thead><tbody><tr><td>Kubernetes</td><td>又簡稱 K8S，是用來管理 container 的叢集管理工具</td></tr><tr><td>Pod</td><td>是 K8S 中可部署的最小單元，一個 pod 裡面可以有多個 container</td></tr></tbody></table><h2>Solutions</h2><p>這是技術文件中最核心的部分，也就是這個功能在你的規劃中如何實現。</p><p>但每個人的想法 / 風格不盡相同，每次開發的功能可能也都大相徑庭，所以沒有一個通用的模板可以參考。</p><p>但根據個人經驗，在撰寫時可以盡量包含下面這些面向：</p><ul><li>What: 這個功能要解決什麼問題？</li><li>Why: 為什麼這樣設計？有沒有什麼背景是團隊需要了解的？或者大家可能會問的問題也可以補充上去。</li><li>When: 有些功能具有時間性，像是 phase1 / phase2，有這類資訊的話也可以補充上去</li><li>Where: 這個功能是放在哪裡？建議可以放在段落標題表示，ex. <code>[後台] 權限列表</code></li><li>Who: 這個段落是寫給誰看的？以後端來說，API 相關資訊需要前後端都知道，但實作細節只有後端工程師需要確認，建議可以放在段落的標題表示，ex. <code>## [For 後端] Schema Change</code></li><li>How: 如何執行？最最最核心的部分，像是 API 的設計 / 想像的 Pseudo code / 實作步驟等等，如果可以用圖片說明的話，建議作圖進一步幫助大家加速理解</li></ul><p>另外有些解決方案可能會想到多種，也可以都寫出來給大家討論</p><h3>如何發想</h3><p>剛開始寫規劃文件的時候，我覺得最難的部分是決定從哪裡著手。經過一段時間的嘗試後，我算是找到了一套適合自己的工作流程。</p><p>首先，我會仔細審閱規格和設計稿，同時記錄下所有我認為程式中需要調整的地方。對於後端來說，這通常意味著確定前端可能需要哪些 API</p><p>在列出所有需要調整的項目之後，我會思考為了完成這些 API 或整個功能，還需要完成哪些其他任務。這可能包括資料庫架構改變，或者是否需要設定定期執行的程式。</p><p>除了這些直接相關的任務之外，還有一些完全沒有畫面可以參考的任務，比如將應用程式容器化。對於這類任務，從終點回推對我來說是一個不錯的策略。舉例來說，如果最終目標是將應用程式部署在 EKS 上，那麼在這之前我就必須先有一個 EKS cluster。但在建立 cluster 之前，我需要先設定網路基礎架構。而要在 K8S 中部署容器，當然我需要先準備好 Dockerfile。通過這種方式，就可以把不足的部分慢慢補齊。</p><h2>Q&amp;A or Discussions</h2><p>這個部分有點像 Solutions 裡面的 Why，但也可以單獨成為一個段落。</p><p>在這裡，你可以列出自己想到的一些問題 / 疑慮，這裡也可以是提供團隊提問的空間。這樣做有助於刺激思考，讓文件更加完善，從而避免個人盲區。</p><h2>Missions</h2><p>最後一部分是將所有需要實現的細節拆分成一個個具體的任務。任務越細越好，這樣在規劃排程時會更準確。此外，這樣做還能提高 Code Review 的品質。</p><table><thead><tr><th>編號</th><th>任務</th><th>任務說明</th><th>估點</th><th>ticket link</th></tr></thead><tbody><tr><td>1</td><td>Routing 建立</td><td>…</td><td>1</td><td>…</td></tr><tr><td>1</td><td>基礎建設</td><td>…</td><td>2</td><td>…</td></tr></tbody></table><h2>Conclusion</h2><p>我自認為我目前還不是可以迅速且熟練地撰寫技術文件的人。我正在努力拿捏文件中需要描述到多少細節，又有哪些部分可以交給實作者自己去思考。</p><p>若將每一個細節都思考透徹，很容易花費過多的時間在規劃階段，時間上甚至可能跟自己發個 PR 的時間差不多。</p><p>另一方面，在撰寫規劃文件的過程中，我們不可能事先想到所有的細節和可能會遇到的問題。難免會有一些在規劃階段沒有預見到的任務，在實作過程中才會浮現出來。面對這樣的情況，我們能做的只有盡最大努力去想到所有可能的情況，並且嘗試把可能遺漏的部分補充完整。</p><p>總結來說，我自己滿推薦開發團隊在實作前撰寫規劃技術文件。它可以幫助團隊快速的達成共識，並進行有效率的溝通，還可以留存當下的情境，作為未來當程式碼變得難以理解時的一個參考依據。從各個面向來看，都為開發過程帶來了很大的效益。</p>]]></content>
    
    
    <summary type="html">如何撰寫前期規劃技術文件</summary>
    
    
    
    
    <category term="Developer" scheme="https://qoosuperman.github.io/tags/Developer/"/>
    
  </entry>
  
  <entry>
    <title>Essential Prompt Patterns for AI Interaction</title>
    <link href="https://qoosuperman.github.io/article/2023-07-10-Essential_Prompt_Patterns_for_AI_Interaction/"/>
    <id>https://qoosuperman.github.io/article/2023-07-10-Essential_Prompt_Patterns_for_AI_Interaction/</id>
    <published>2023-07-10T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<h2>Introduction</h2><p>最近我在 Coursera 上了 “<a href="https://www.coursera.org/learn/prompt-engineering/home/week/1" target="_blank" rel="noopener">Prompt Engineering for ChatGPT</a>” 的課程，並從中學習到了許多知識，因此我想把主要的學習重點整理出來，以便日後參考</p><p>在這篇文章中，我將結合課程內容和我自己的觀點，主要的內容將圍繞課程中提到的各種 Prompt Engineering pattern，並且大部分的 pattern 會分享我嘗試的範例。</p><p>這是一篇很～長的文章，也許做個書籤，當作工具來使用會比較適合，不建議一次看完。我甚至比較建議直接去上前面提到的 <a href="https://www.coursera.org/learn/prompt-engineering/home/week/1" target="_blank" rel="noopener">課程</a>，此課程雖然免費但我覺得相當有品質！</p><h2>Outline</h2><ul><li><a href="#introduction">Introduction</a></li><li><a href="#%E4%BB%80%E9%BA%BC%E6%98%AF-prompt">什麼是 Prompt</a></li><li><a href="#root-prompt">Root Prompt</a></li><li><a href="#prompt-%E7%9A%84%E5%BC%B7%E5%BA%A6">Prompt 的強度</a></li><li><a href="#prompt-patterns">Prompt Patterns</a><ul><li><a href="#persona-pattern">Persona Pattern</a></li><li><a href="#prompt-question-refinement-pattern">Prompt Question Refinement Pattern</a></li><li><a href="#cognitive-verifier-pattern">Cognitive Verifier Pattern</a></li><li><a href="#audience-persona-pattern">Audience Persona Pattern</a></li><li><a href="#prompt-flipped-interaction-pattern">Prompt Flipped Interaction Pattern</a></li><li><a href="#few-shot-example-pattern">Few Shot Example Pattern</a></li><li><a href="#chain-of-thoughts-pattern">Chain of Thoughts Pattern</a></li><li><a href="#react-pattern">ReAct Pattern</a></li><li><a href="#gameplay-pattern">Gameplay Pattern</a></li><li><a href="#template-pattern">Template Pattern</a></li><li><a href="#metalanguage-creation-pattern">Metalanguage Creation Pattern</a></li><li><a href="#recipe-pattern">Recipe Pattern</a></li><li><a href="#prompt-alternative-approaches-pattern">Prompt Alternative Approaches Pattern</a></li><li><a href="#ask-for-input-pattern">Ask for input pattern</a></li><li><a href="#prompt-outline-expansion-pattern">Prompt Outline Expansion pattern</a></li><li><a href="#menus-actions-pattern">Menus Actions Pattern</a></li><li><a href="#fact-check-pattern">Fact Check Pattern</a></li><li><a href="#tail-generation-pattern">Tail Generation Pattern</a></li><li><a href="#semantic-filter-pattern">Semantic Filter Pattern</a></li></ul></li></ul><h2>什麼是 Prompt</h2><p>在介紹 Pattern 之前，首先來介紹一下 Prompt</p><p>我直接問 ChatGPT 這個問題，我認為他的回答相當精確：</p><blockquote><p>In summary, the prompt is the input or instruction given to the language model to initiate a conversation or generate a response. It helps to define the context and shape the output of the model.</p></blockquote><p>我們丟給 Large Language Model(ChatGPT 即一種 Large Language Model, 以下簡稱 LLM) 的 input 就稱為 prompt</p><p>隨著我們提供的 prompt 愈來愈多，結合 ChatGPT 的回應，這些對話逐漸形成了一種 “情境”，這些情境對接下來的對話有很大的影響。</p><p>目前，大部分人使用 ChatGPT 的方式是問一個問題並讓 ChatGPT 回答。但 LLM 最初並非設計來重複回答問題的，它的主要功能是透過回應，讓我們提供的 prompt 變得完整。例如，我們給它一段知名歌曲的歌詞，它會嘗試接續下一段歌詞。</p><p>如果我們用這種方式來思考，而不是只透過一個問題試圖獲得 ChatGPT 完全正確的答案，可以讓 ChatGPT 展現更大的價值。</p><blockquote><p>ChatGPT 主要功能是透過回應，讓 prompt 變得完整</p></blockquote><img src="https://hackmd.io/_uploads/BylA5j-Y2.png" alt="" height="50%" width="50%"><h2>Root Prompt</h2><p>Root Prompt 是指在開始之前，先給 ChatGPT 一項必須遵循的原則。</p><p>事實上，無論是 ChatGPT 或是如 Bing 這樣的工具，他們應該都藏有一些隱藏的根本提示，例如無法回答 2021 年之後的數據，或是無法提供某些產品序號等等。</p><p>當然目前還有一些人在持續嘗試破解這些 hidden root prompt，像是用感人的故事來騙 Windows 序號:</p><p><img src="https://cdn.hk01.com/di/media/images/dw/20230620/747802489729847296682940.png/QmLuLhw8SVIK4M4mVPx250vRsq24UowrbVPC7W1Twu0?v=w1920" alt=""></p><h2>Prompt 的強度</h2><p>LLM 被設計為具有一定的隨機性，因此，如果我們重複對它提出相同的問題，每次得到的結果通常都會不同。然而，這實際上與提示的強度有關。</p><p>例如 “兩隻老虎” 這個例子。這首歌詞已經被訓練過數千萬次，因此它成為一個強度高的 Prompt，即使我們問了10次，每次都會得到相同的結果。</p><p>但是，如果今天我們將歌詞改為&quot;兩隻兔子&quot;，我們很快就會得到完全不同的回答。這類 Prompt 的強度就很明顯相對較弱：</p><img src="https://hackmd.io/_uploads/By_m3sWY2.png" alt="" height="50%" width="50%"><h2>Prompt Patterns</h2><p>就我的個人觀點，Prompt Pattern 就像是程式語言中常見的設計模式 Design Pattern。在初期，並沒有這些模式存在，但隨著大家經驗的積累，一些被認為普遍好用的 Pattern 就被大家所接受，並逐漸形成並流傳</p><p>使用 Pattern 的好處在於省去一些思考的時間。我們可以從人們累積的這些模式中找到剛好可以解決目前問題的那一種，並直接套用。這種方式通常比我們自己憑空思考更為節省時間，且效果也往往更好。</p><p>以下就一一介紹課程中提到的 pattern</p><h3>Persona Pattern</h3><p>在日常生活中，當我們遇到某些問題時，可能會想尋求專家或具有某種特殊技能的人的意見。這時候 Persona Pattern 就非常適用。</p><p>我們會要求 ChatGPT 扮演這個角色，然後向它提問，像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Act as a kubernetes expert.</span><br><span class="line">Explain what is kubernetes to me.</span><br></pre></td></tr></table></figure><p>使用時，不要被你的想像力所限制，你可以要求它扮演動物甚至是電腦程式:</p><p><img src="https://hackmd.io/_uploads/Hk4kGBNY3.png" alt=""></p><p>網路上甚至也有整理 <a href="https://domyweb.org/chatgpt/" target="_blank" rel="noopener">各種職業的詠唱法</a></p><h3>Prompt Question Refinement Pattern</h3><p>由於我們不知道大型語言模型 (LLM) 是如何被訓練的，因此我們很容易提出一個問題，卻未能得到期望的答案。在這種情況下，我們可以用一個較為廣泛的問題，請求它幫我們精煉出一個更好的問法，從而得到我們想要的結果。</p><p>如果懶得把他生出來的問題再複製貼上去問他，可以加上 <code>Prompt me if I would like to use the better version instead</code></p><p>我的使用範例：<br><img src="https://hackmd.io/_uploads/H1rTPBEY3.png" alt=""></p><h3>Cognitive Verifier Pattern</h3><p>使用此 pattern 的目的是讓 ChatGPT 在被問問題時，會自己提出更多細節的問題，以便能更精確地回答問題。</p><p>在我的想像中，這可以作為我們思考問題時進行 brainstorming 的工具。</p><p>我的使用範例：<br><img src="https://hackmd.io/_uploads/Hy7Sor4Yh.png" alt=""></p><h3>Audience Persona Pattern</h3><p>之前提到過 Persona Pattern ，那是請 ChatGPT 扮演一個角色。</p><p>而這種模式則相反，是將自己塑造成一個指定的角色，然後請 ChatGPT 根據這個角色的特性來調整其回應。</p><p>像是把自己塑造成中二生：<br><img src="https://hackmd.io/_uploads/Synv3BNY3.png" alt=""></p><h3>Prompt Flipped Interaction Pattern</h3><p>在大部分情況下，我們問，而 ChatGPT 回答。然而，這個 pattern 的操作方式則是讓 ChatGPT 持續提問，直到它認為它可以回答這個問題為止。</p><p>這個 pattern 跟 Prompt Cognitive Verifier Pattern 的差異在於，這個 pattern 中， ChatGPT 會不斷提問直到他有辦法回答，而 Prompt Cognitive Verifier Pattern 則是一開始就給你他想額外知道的細節的答案，知道了這些他就有辦法回答你的問題，兩者稍有不同</p><p>比方說請他幫忙診斷網路問題：<br><img src="https://hackmd.io/_uploads/S1D7RrNYn.png" alt=""></p><h3>Few Shot Example Pattern</h3><p>Few Shot Example Pattern 是根據之前提到的 LLM 的特性：LLM 會嘗試透過其回答使我們提供的提示變得完整。</p><p>在此 pattern 中，我們會給 ChatGPT 許多相似的例子，這些例子有一定的規則可以遵循。換句話說，我們是在用我們訂定的規則來教它，像是：</p><img src="https://hackmd.io/_uploads/rJd6ggvK3.png" alt="" height="50%" width="50%"><p>有了這樣的規則，也可以讓它自由發想：</p><img src="https://hackmd.io/_uploads/H1IQZxvth.png" alt="" height="50%" width="50%"><p>使用這個 pattern 時需要注意，必須給予ChatGPT足夠的資訊量，才能得到我們想要的答案。例如在下面的例子中，如果我們要的是物體的軟硬度，則可以將 “Output” 改為 “surface feeling” 這種字眼，或者給予更多範例讓它知道我們只在乎物體的軟硬度。</p><img src="https://hackmd.io/_uploads/SJ89WlPY2.png" alt="" height="50%" width="50%"><h3>Chain of Thoughts Pattern</h3><p>這 pattern 可以視為 Few Shot Example Template 的變形，在此 pattern 中，我們會主動提供幾個思考問題的邏輯給 ChatGPT，然後要求它回答另一個問題。</p><p>這個 pattern 的用途在於，ChatGPT 有時會回答出一些錯誤的答案（尤其在數學問題方面），如果讓它將中間的思考邏輯表達出來，當它的中間邏輯正確時，最後的答案更可能是正確的。</p><p>然而，我個人覺得這個 pattern 似乎較少用武之地。加上現在 ChatGPT 已經被訓練得更聰明，因此很少有需要使用此 pattern 的場合。</p><p>提供課程上的 prompt 做為參考:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Q: I have four bike racers start a race and travel an average of 30mph. They each race for 2hrs. Is the total number of miles ridden by all riders greater than 200?</span><br><span class="line">A: Reasoning - Each rider will ride 30mph x 2hrs = 60 miles. I have four riders. Therefor, the total number of miles ridden by the ridders is 4 x 60 miles = 240 miles. Answer- Yes</span><br><span class="line"></span><br><span class="line">Q: Iam in a space ship without gravity. I have a cup with a needle in it. I move my foot on the bed, knocking over the cup onto the floor. I lift a book up and put it on a desk. Is anything on the floor?</span><br><span class="line">A: Reasoning - &lt;REASONING&gt; Answer - &lt;ANSWER&gt;</span><br></pre></td></tr></table></figure><h3>ReAct Pattern</h3><p>ReAct Pattern 可以看作是 Chain of Thoughts Pattern 的一種變形</p><p>其使用方式是透過一系列的原因（reason）和行動（action）來讓ChatGPT知道它可以使用外部工具來達成目標。</p><p>當它獲得了外部工具提供的資訊後，就可以繼續進行下一步驟。</p><p>然而，這種方法通常需要插件 (plugin) 或是透過讓 ChatGPT 使用自己寫的外部程式，才能發揮最大效益。例如，目前很多人在使用的 <a href="https://python.langchain.com/docs/get_started/introduction.html" target="_blank" rel="noopener">LangChain</a> 據我所知就是使用 ReAct pattern 來寫 prompt。</p><h3>Gameplay Pattern</h3><p>使用遊戲來學習通常可以讓學習效率提升，我們也可以利用這點透過 ChatGPT 進行學習。我們可以給 ChatGPT 一個我們想要學習的主題，並請他設計遊戲給我們。</p><p>這個 pattern 有點像是前面提到的 Flipped Interaction Pattern 的變形，同樣也是由 ChatGPT 提問，我們來回答，但這次更進一步需要 ChatGPT 幫忙想出一個遊戲跟這個遊戲的規則出來</p><p>像是透過 ChatGPT 學習 SQL 語法：<br><img src="https://hackmd.io/_uploads/H1tHiTvK2.png" alt=""><br><img src="https://hackmd.io/_uploads/rk9UsaPtn.png" alt=""></p><h3>Template Pattern</h3><p>Template Pattern 就是讓 ChatGPT 按照你想要的格式去回答，因此需要主動給他一個 template，請他按照這個格式去回答</p><p>通常會給 ChatGPT 一些 placeholders 請他替換掉。但提供 placeholders 的時候要注意最好是有意義的文字，而不是單純的 placeholder</p><p>比方說下面這兩個例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### Summary: &lt;ONE SENTENCE SUMMARY&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### Summary: &lt;OUTPUT&gt;</span><br></pre></td></tr></table></figure><p>ChatGPT 可以明顯從 ONE SENTENCE SUMMARY 知道他產生的內容被限定在一個句子的長度</p><p>像是請他按照我要的格式去寫規劃的行程：<br><img src="https://hackmd.io/_uploads/rJnD1AwFh.png" alt=""><br><img src="https://hackmd.io/_uploads/SkAd1CDt3.png" alt=""><br>（為什麼他說的好像去北韓旅遊是一件很普通的事情 XD）</p><h3>Metalanguage Creation Pattern</h3><p>Meta Language 通常被用於特定的交流情境。例如消防員在使用對講機通報情況時，由於狀況緊急，他們可能會使用特定的術語，來簡短且精確地傳達信息。</p><p>另一個例子是，我們可能希望用更簡短的方式與 ChatGPT 交流，因此會創造一些新的表達方式。</p><p>這個 Pattern 可以用來教 ChatGPT 學習和理解這些特定的表達方式。這個 pattern 與 Few-Shot Example Pattern 類似，因為它也是通過提供一些範例，讓 LLM 學習和理解新的規則</p><p>範例：做出另一個表達旅遊地點跟天數的語法</p><p><img src="https://hackmd.io/_uploads/HyD7NAwt2.png" alt=""><br><img src="https://hackmd.io/_uploads/SJ4NV0wtn.png" alt=""></p><h3>Recipe Pattern</h3><p>有時候我們知道一個問題的部分答案，這時候可以給 ChatGPT 知道的資訊，要求他把這些資訊拼湊出來變成完整的答案，這樣的方式即 Recipe Pattern</p><p>下面的範例中，我只知道我開車的起點跟終點，還有必須經過哪些中繼站，加上必須達成的條件，請他規劃完整的旅程：<br><img src="https://hackmd.io/_uploads/rkTJUAvt2.png" alt=""></p><h3>Prompt Alternative Approaches Pattern</h3><p>我們可以請 ChatGPT 提供多種不同方法或策略。這可以幫助我們思考，並可能找到最好的解決方案，就像有人在幫忙做 brain strom 一樣。</p><p>像是可以利用這個 pattern 來幫忙想出更好的 prompt:<br><img src="https://hackmd.io/_uploads/HkV2oCPKn.png" alt=""><br><img src="https://hackmd.io/_uploads/SyvajCvK2.png" alt=""></p><h3>Ask for input pattern</h3><p>這個 pattern 與其說是 pattern 更像是一個小技巧</p><p>我們有時候會遇到一種情況：只想讓 ChatGPT 聽完描述，而不做任何回應。但通常 ChatGPT 會過於主動，產生了一些我們不需要的內容。為了解決這種情況，我們可以利用 Ask for Input Pattern 來控制他的行為。</p><p>具體來說，我們只需要在 Prompt 最後加上 <code>Ask me for the first task/question</code> 就可以達到目的</p><p>以上一個例子來改寫的話，就會像下面這樣：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For every prompt I give you, If there are alternative ways to word a prompt that I give you, list the best alternate wordings . Compare/contrast the pros and cons of each wording.</span><br><span class="line"></span><br><span class="line">Ask me for the first prompt</span><br></pre></td></tr></table></figure><h3>Prompt Outline Expansion pattern</h3><p>這個 pattern 主要適用於需要寫文章、書籍或簡報大綱的時候。</p><p>我們可以提供需要介紹的主題，然後讓 ChatGPT 來構思大綱。接著，又可以要求 ChatGPT 對其中幾點產生具體的內容。</p><p>如果對 ChatGPT 生成的大綱不滿意，也可以自己修改過後，請他針對新版本的內容更新細節</p><p>可能有人會問，為什麼不直接讓 ChatGPT 生成所有內容再進行總結？</p><p>主要是因為 ChatGPT 仍然存在輸入和輸出的限制。它無法直接一次輸出一本書的內容，同樣也不能一次處理超過太大量的文字內容。因此，我們需要一種方法來分段處理，但同時又能將所有的片段組合在一起。</p><p>如果今天我想做一個介紹 Kubernetes 的簡報，我可能會這樣做：<br><img src="https://hackmd.io/_uploads/Bys_gyOF3.png" alt=""><br><img src="https://hackmd.io/_uploads/ByqKxJuFn.png" alt=""><br><img src="https://hackmd.io/_uploads/r12qe1dK2.png" alt=""></p><h3>Menus Actions Pattern</h3><p>當我們需要重複 prompt 某一段話，來讓 ChatGPT 執行特定行為的話，可以考慮使用 Menu Action Pattern。這個 Pattern 將常用的 prompt 轉變成一種術語，將 ChatGPT 塑造成一個能理解這些術語的程式。</p><p>除此之外，如果要打造自動客服系統，我們可以把 Menu Actions Pattern 放置在 Root Prompt。比起讓客戶自由發問，限制客戶的問題必須在這些選項內可能會更能達到我們想要的效果，並提供更精確的回答。</p><p>這個 pattern 有點像是前面提到的 Prompt meta language creation pattern，目的都是要讓 ChatGPT 理解某種術語</p><p>比方說可以把 ChatGPT 塑造成一個管理 todo list 的小程式：<br><img src="https://hackmd.io/_uploads/By6sfydF3.png" alt=""><br><img src="https://hackmd.io/_uploads/HkMAzJdt3.png" alt=""></p><h3>Fact Check Pattern</h3><p>ChatGPT 常被詬病的回答的答案不正確。但實際上 ChatGPT 的主要功能是生成文字，因此，對於其回答的正確性，我們或許不能過於苛求。</p><p>儘管如此，我們有一種工具可以用來輔助我們的判斷，就是 Fact Check Pattern</p><p>這個 pattern 的概念是：我們讓 ChatGPT 生成內容時，我們也可以同時要求它列出這個回答是基於哪些事實或資訊來給出的。</p><p>如果我們檢查這些內容，並發現其中有錯誤的論述，那麼上述生成的內容很可能是錯誤的。</p><p>這些論述可以被視為我們需要至少驗證的事實。更重要的是，這種模式可以幫助我們進入一個思考內容正確性的模式。如果我們更謹慎對比這些論述和內容，雖然可能仍然難以避免某些錯誤，但可以降低錯誤發生的機率。</p><p>以下面的例子來說，我就可以果斷判斷上面的內容不需要理解，因為第五點就明顯跟官方文件提到的不吻合：</p><p><img src="https://hackmd.io/_uploads/SJBX8JOYh.png" alt=""><br><img src="https://hackmd.io/_uploads/HkEELJ_F3.png" alt=""><br><img src="https://hackmd.io/_uploads/rJ648JOFn.png" alt=""></p><h3>Tail Generation Pattern</h3><p>當在設定一個規則的前提下與 ChatGPT 溝通，隨著對話內容增加，ChatGPT 有時會忘記一開始設定的規則。</p><p>這時 Tail Generation Pattern 就非常適合使用，簡單來說，就是讓 ChatGPT 在回答的最後復述一次這個條件或提醒他不要忘記的事項。</p><p>因為 ChatGPT 不斷提醒自己這些規則，有助於確保他會持續遵循這些指示</p><p>以前面 Outline Expander Pattern 的例子做說明，可以像這樣修改  prompt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Act as an outline expander. Generate a bullet point outline based on the input that I give you and then ask me for which bullet point you should expand on. Create a new outline for the bullet point that I select.</span><br><span class="line">At the end, ask me for what bullet point to expand next. Ask me for what to outline.</span><br></pre></td></tr></table></figure><h3>Semantic Filter Pattern</h3><p>我們可以利用 LLM 的語言分析能力，從一段內容中提取我們需要的資訊，或將不需要的資訊剔除。</p><p>比方說，當提供一段資料時，我們希望能將可能識別出某人身份的敏感資訊移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filter the following information to remove any personally identifying information or information that could potentially be used to re-identify the person.</span><br></pre></td></tr></table></figure><h2>Summary</h2><p>完成這堂課之後，讓我對 prompt 有了更深的認識，並且理解到要有效運用 ChatGPT 這類工具，真的會需要一定程度的想像力與大量的練習</p><p>在練習的過程中，我比較不習慣的部分是大量的閱讀和打字，尤其在 ChatGPT 使用英文的效果遠勝於中文的情況下，需要大量閱讀英文和輸出英文句子，這讓我無法迅速反應。</p><p>目前 Large Language Model 的發展還在初期的階段，我期待它能讓我們的生活更便利。同時，我也希望能追上這股潮流，而不是成為那群無法跟上時代步伐，被取而代之的人。</p>]]></content>
    
    
    <summary type="html">Essential Prompt Patterns for AI Interaction</summary>
    
    
    
    
    <category term="AI" scheme="https://qoosuperman.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AWS EKS 中的身份驗證與權限管理策略</title>
    <link href="https://qoosuperman.github.io/article/2023-06-29-Identity_Authentication_and_Permission_Management_Strategies_in_AWS_EKS/"/>
    <id>https://qoosuperman.github.io/article/2023-06-29-Identity_Authentication_and_Permission_Management_Strategies_in_AWS_EKS/</id>
    <published>2023-06-29T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.535Z</updated>
    
    <content type="html"><![CDATA[<h2>Outline</h2><ul><li><a href="#introduction">Introduction</a></li><li><a href="#why">Why</a></li><li><a href="#iam-roles-for-service-accounts%28irsa%29">IAM roles for service accounts(IRSA)</a></li><li><a href="#aws-iam-authenticator">AWS IAM Authenticator</a></li><li><a href="#%E8%B8%A9%E9%9B%B7%E9%81%8E%E7%A8%8B">踩雷過程</a></li><li><a href="#references">References</a></li></ul><h2>Introduction</h2><p>Amazon Elastic Kubernetes Service (EKS) 是在AWS上使用Kubernetes(簡稱 K8S)進行容器管理的一個選項</p><p>我們可以使用 AWS 的 EC2 來自行搭建 Kubernetes，但 EKS 的好處在於它能夠自動管理 Kubernetes 的 control plane，這樣我們只需支付一點額外費用，就不需要花費人力去管理複雜 control plan運作。</p><p>最近我們正在使用 terraform 搭建新的 EKS cluster，正在處理EKS的權限時遇到了一些小問題，我想稍微記錄一下這些經驗，並介紹 EKS 的身份驗證與權限管理策略</p><h2>Why</h2><p>接下來，讓我們談談為什麼需要處理EKS的權限。</p><p>讓我們用兩個例子來說明：</p><ol><li>在 EKS 上運行的 Pod 無法直接存取 AWS 的 S3 資源，因為它們沒有相應的 AWS IAM 權限。</li><li>如果作為 IAM User 登入，您也無法直接控制 Kubernetes cluster，因為 IAM User 沒有Kubernetes Role 的權限。</li></ol><p>為了應對這兩種情況，AWS 提供了兩種解決方案：</p><ul><li>IAM roles for service accounts(IRSA)</li><li>AWS IAM Authenticator</li></ul><p>接著會一一介紹他們</p><h2>IAM roles for service accounts(IRSA)</h2><p>通常，我們會為 Pod 分配一個 Service Account，而 IRSA 這個功能允許 Kubernetes 的 Service Account 拿到 IAM Role 的權限，透過這種方式使 Pod 能夠操作部分 AWS 資源</p><p>具體的實現原理很複雜，而我發現下圖解釋得很清楚，有空的話也可以去看看 <a href="https://mohaamer5.medium.com/iam-roles-for-service-accounts-with-eks-irsa-good-bye-aws-credentials-1cdf1fa5192" target="_blank" rel="noopener">原文</a><br><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHxhoE-uJwVQEdIhQMTn3A.png" alt=""></p><p>能做到的前提主要有兩個：</p><ol><li>AWS IAM 支援使用 OIDC JSON Web Token(JWT) 做認證(但建立 Role 的時候要指定支援)</li><li>Kubernetes 的 Service Account 在某個版本後開始支援 projected service account tokens，他也是基於 OIDC JWT</li></ol><p>有了這些設定，我們就可以實現在 Kubernetes cluster 中讓 Service Account 具有 IAM Role 的權限，從而使 Pod 能夠訪問所需的AWS資源</p><h3>實作細節</h3><p>接下來說明如何用 terraform 做出有 IAM role 權限的 Service Account</p><p>這篇 <a href="https://antonputra.com/terraform/how-to-create-eks-cluster-using-terraform/#create-eks-cluster-using-terraform" target="_blank" rel="noopener">文章</a> 提供了詳細的說明，我用裡面的例子來說明</p><ol><li>開啟 EKS cluster 的 OIDC provider 功能（它不會自動啟用）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_openid_connect_provider&quot; &quot;eks&quot; &#123;</span><br><span class="line">  client_id_list  = [&quot;sts.amazonaws.com&quot;]</span><br><span class="line">  thumbprint_list = [data.tls_certificate.eks.certificates[0].sha1_fingerprint]</span><br><span class="line">  url             = aws_eks_cluster.demo.identity[0].oidc[0].issuer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>建立提供 serveice account 使用的 IAM Role，在 assume role policy 中要記得註明可以由 OIDC provider assume 為此 IAM Role</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 這個 assume role policy 為重點</span><br><span class="line">data &quot;aws_iam_policy_document&quot; &quot;test_oidc_assume_role_policy&quot; &#123;</span><br><span class="line">  statement &#123;</span><br><span class="line">    actions = [&quot;sts:AssumeRoleWithWebIdentity&quot;]</span><br><span class="line">    effect  = &quot;Allow&quot;</span><br><span class="line"></span><br><span class="line">    condition &#123;</span><br><span class="line">      test     = &quot;StringEquals&quot;</span><br><span class="line">      variable = &quot;$&#123;replace(aws_iam_openid_connect_provider.eks.url, &quot;https://&quot;, &quot;&quot;)&#125;:sub&quot;</span><br><span class="line">      values   = [&quot;system:serviceaccount:default:aws-test&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    principals &#123;</span><br><span class="line">      identifiers = [aws_iam_openid_connect_provider.eks.arn]</span><br><span class="line">      type        = &quot;Federated&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_role&quot; &quot;test_oidc&quot; &#123;</span><br><span class="line">  assume_role_policy = data.aws_iam_policy_document.test_oidc_assume_role_policy.json</span><br><span class="line">  name               = &quot;test-oidc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在建立 service account 時，確保在 annotation 中寫上相應的 IAM Role arn</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">aws-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="comment"># 重點在這</span></span><br><span class="line">    <span class="attr">eks.amazonaws.com/role-arn:</span> <span class="string">arn:aws:iam::424432388155:role/test-oidc</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">aws-cli</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">aws-test</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">aws-cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">amazon/aws-cli</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">[</span> <span class="string">"/bin/bash"</span><span class="string">,</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"--"</span> <span class="string">]</span></span><br><span class="line">    <span class="attr">args:</span> <span class="string">[</span> <span class="string">"while true; do sleep 30; done;"</span> <span class="string">]</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure><ol start="4"><li>如果此 IAM Role 有 S3 權限，那麼新建立的 pod 就可以訪問 S3 的資源</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec aws-cli -- aws s3api list-buckets</span><br></pre></td></tr></table></figure><h2>AWS IAM Authenticator</h2><p>現在我們來探討如何使用 aws-iam-authenticator 將 IAM Role / User 綁定到 K8S 的 group，以便透過 IAM Role 操控 K8S。</p><p>當我們要使用 IAM 權限來訪問 Kubernetes 資源時，就會觸發這個機制，如下圖所示：</p><p>1.我們的電腦首先向 AWS STS 要求代表當前 IAM 身份的 token（未繪製在圖上），然後帶著 token 訪問 Kubernetes 的 API server</p><p>2.Kubernetes 的 API server 使用該 token 訪問 AWS IAM Authenticator server 的 <code>/authenticate</code> API</p><p>3+4.AWS IAM Authenticator server 對該 token 進行處理和初步驗證，然後將傳給 AWS STS，會得到 GetCallerIdentityResponse</p><p>5.AWS IAM Authenticator server 使用 <code>aws-auth</code> configmap 中的規則，將 GetCallerIdentityResponse 中的內容映射到相應的 Kubernetes 身份（group / username）</p><p>6.一旦知道 Kubernetes 的相應身份，Kubernetes cluster 就可以使用原有的 RBAC 機制來處理該請求，並將 response 返回給我們。</p><p><img src="https://7903508.fs1.hubspotusercontent-na1.net/hub/7903508/hubfs/newblog1.png?width=624&amp;name=newblog1.png" alt=""></p><h3>實作細節</h3><p>我使用 terraform 中的 <a href="https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs" target="_blank" rel="noopener">kubectl provider</a> 來實作</p><ol><li>首先建立要使用的 Kubernetes ClusterRole 和 ClusterRoleBinding。我將 deployer 這個 role 綁定到 deployers 這個 group。需要特別注意的是，deployers group的資源不需要額外建立，Kubernetes 會自動處理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;kubectl_manifest&quot; &quot;test_role&quot; &#123;</span><br><span class="line">  yaml_body = &lt;&lt;-EOF</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: deployer</span><br><span class="line">  labels:</span><br><span class="line">    k8s-addon: cluster-autoscaler.addons.k8s.io</span><br><span class="line">    k8s-app: cluster-autoscaler</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources:</span><br><span class="line">      - &quot;namespaces&quot;</span><br><span class="line">      - &quot;pods&quot;</span><br><span class="line">      - &quot;services&quot;</span><br><span class="line">      - &quot;replicationcontrollers&quot;</span><br><span class="line">      - &quot;persistentvolumeclaims&quot;</span><br><span class="line">      - &quot;persistentvolumes&quot;</span><br><span class="line">    verbs: [&quot;watch&quot;, &quot;list&quot;, &quot;get&quot;]</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;kubectl_manifest&quot; &quot;test_role_binding&quot; &#123;</span><br><span class="line">  yaml_body = &lt;&lt;-EOF</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: deployer</span><br><span class="line">subjects:</span><br><span class="line">  - kind: Group</span><br><span class="line">    name: deployers</span><br><span class="line">    apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: deployer</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接下來建立要使用的 IAM Role。由於希望多人可以登入並使用此角色，因此將可以使用者清單放入 deployer_users_list 中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_iam_role&quot; &quot;deployer&quot; &#123;</span><br><span class="line">  name = &quot;deployer&quot;</span><br><span class="line"></span><br><span class="line">  assume_role_policy = data.aws_iam_policy_document.deployer.json</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &quot;aws_iam_policy_document&quot; &quot;deployer&quot; &#123;</span><br><span class="line">  version = &quot;2012-10-17&quot;</span><br><span class="line">  statement &#123;</span><br><span class="line">    effect = &quot;Allow&quot;</span><br><span class="line">    actions = [</span><br><span class="line">      &quot;sts:AssumeRole&quot;</span><br><span class="line">    ]</span><br><span class="line">    principals &#123;</span><br><span class="line">      type        = &quot;AWS&quot;</span><br><span class="line">      identifiers = var.deployer_users_list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>因為 aws-auth configmap 一開始就存在，所以我們需要在 Terraform 中創建一個空殼，然後將此 configmap import</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform import module.k8s-resources.kubectl_manifest.aws-auth v1//ConfigMap//aws-auth//kube-system</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 <code>aws-auth</code> configmap 的 mapping 規則</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;kubectl_manifest&quot; &quot;aws-auth&quot; &#123;</span><br><span class="line">  yaml_body = &lt;&lt;-EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: aws-auth</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  mapRoles: |</span><br><span class="line">    - groups:</span><br><span class="line">      - deployers</span><br><span class="line">      username: &quot;aws:&#123;&#123;AccountID&#125;&#125;:eks-deployer:&#123;&#123;SessionName&#125;&#125;&quot;</span><br><span class="line">      rolearn: $&#123;var.deployer-role-arn&#125;</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>要使用的開發者們在使用這個角色進行登入之前，要像下面這樣來設定 <code>~/.aws/config</code> 跟 <code>~/.aws/credentials</code> 檔案</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ~/.aws/config</span><br><span class="line">[profile eks-admin]</span><br><span class="line">role_arn = arn:aws:iam::&lt;account id&gt;:role/&lt;role name&gt;</span><br><span class="line">source_profile = anthony</span><br><span class="line"></span><br><span class="line"># ~/.aws/credentials</span><br><span class="line">[anthony]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="6"><li>最後，透過 aws 指令完成 kube config 設定</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws eks update-kubeconfig  --name &lt;cluster name&gt; --region &lt;region&gt; --profile eks-admin</span><br></pre></td></tr></table></figure><p>這樣，就可以使用 IAM Role 來扮演使用 Kubernetes 的 deployer role 來管理 cluster 並進行相關操作了</p><h2>踩雷過程</h2><h3>IRSA</h3><p>根據別人的 <a href="https://antonputra.com/terraform/how-to-create-eks-cluster-using-terraform/#create-iam-oidc-provider-eks-using-terraform" target="_blank" rel="noopener">建議</a>，我決定在建立完 OIDC provider 之後，測試建立一個具有 S3 權限的 IAM Role，並將服務帳戶關聯到該角色，以便讓 Pod 可以取得 S3 資源的訪問權限</p><p>在創建 OIDC provider 時，我沒有遇到問題，然而，在建立 Cluster 內的 Pod 時，我一開始完全無法建立</p><p>踩雷過程中的第一個問題是：預設情況下，只有建立 EKS Cluster 的 IAM User 才擁有該 Cluster 的 admin 權限。我猜測這是因為 AWS 不希望該權限被移除後沒有人能夠操作 Cluster</p><p>由於 Cluster 是透過持續交付流程 (CD) 建立的，如果我想操作該 Cluster，就需要使用跟 CD 中相同的 IAM User 身份進行操作，或者透過 aws-iam-authenticator 為我的 IAM User 提供權限</p><h3>aws-iam-authenticator</h3><p>在嘗試使用 <a href="https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs" target="_blank" rel="noopener">kubectl provider</a> 建立 Kubernetes 資源時，我一直遇到問題，並且持續收到 “Unauthorized” 的錯誤訊息。這讓我很難判斷問題的來源。</p><p>我嘗試過 Terraform 的 <a href="https://developer.hashicorp.com/terraform/internals/debugging" target="_blank" rel="noopener">調整 Log level 為 debug 的方法</a> ，但並沒有提供太多幫助</p><p>kubectl provider 的參數主要包含三個：host / cluster_ca_certificate / token，我也嘗試將這些參數的值輸出到root level，以檢查它們的值是不是正常，但這同樣並沒有提供太多幫助如果是在 module level output 的參數，無法透過 <code>terraform output</code> 指令確認, <a href="https://stackoverflow.com/questions/52503528/why-is-my-terraform-output-not-working-in-module" target="_blank" rel="noopener">reference</a>）</p><p>最後，我在 CloudTrail 中看了 AWS 操作記錄，才發現我一直以為已經切換到 CD 流程使用的 IAM User，但實際上並未完全切換。意識到這點後，問題才得以解決</p><p>另外，特別提一下，aws-auth configmap 可以將 Kubernetes group 的權限綁定到 IAM User 或 IAM Role（目前無法綁定到 IAM group）。它們分別對應 configmap 中的 mapUsers 和 mapRoles 部分，而這裡的 username 將 IAM Role 在 Kubernetes Cluster 中映射到指定的名稱，所以通常會使用 “aws::eks-developer:” ，這樣做才可以知道當前操作 Cluster 的人的身份(<a href="https://dev.to/aws-builders/eks-auth-deep-dive-4fib" target="_blank" rel="noopener">reference</a>)</p><p>下面的 mapRoles 規則允許名為 abc 的 Role 使用 system:masters 這個 group 的權限來操作 Kubernetes，而 mapUsers 則允許名為 a-user 的 user 使用 system:masters 這個 group 的權限來操作 Kubernetes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">    name: aws-auth</span><br><span class="line">    namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  mapRoles: |</span><br><span class="line">    - rolearn: arn:aws:iam::555555555555:role/abc</span><br><span class="line">      username: ops-user</span><br><span class="line">      groups:</span><br><span class="line">        - system:masters</span><br><span class="line">  mapUsers: |</span><br><span class="line">    - userarn: arn:aws:iam::555555555555:user/a-user</span><br><span class="line">      username: admin</span><br><span class="line">      groups:</span><br><span class="line">        - system:masters</span><br></pre></td></tr></table></figure><h2>References</h2><p><a href="https://antonputra.com/terraform/how-to-create-eks-cluster-using-terraform/#create-iam-oidc-provider-eks-using-terraform" target="_blank" rel="noopener">How to Create EKS Cluster Using Terraform?</a></p><p><a href="https://antonputra.com/terraform/how-to-create-eks-cluster-using-terraform/#create-public-load-balancer-on-eks" target="_blank" rel="noopener">How to create EKS Cluster using Terraform MODULES?</a></p><p><a href="https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html" target="_blank" rel="noopener">AWS document on aws-auth configmap setting</a></p><p><a href="https://blog.lightspin.io/exploiting-eks-authentication-vulnerability-in-aws-iam-authenticator" target="_blank" rel="noopener">Exploiting Authentication in AWS IAM Authenticator for Kubernetes</a></p>]]></content>
    
    
    <summary type="html">Identity Authentication and Permission Management Strategies in AWS EKS</summary>
    
    
    
    
    <category term="Devops" scheme="https://qoosuperman.github.io/tags/Devops/"/>
    
    <category term="AWS" scheme="https://qoosuperman.github.io/tags/AWS/"/>
    
    <category term="K8S" scheme="https://qoosuperman.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Swiss Travel Notes</title>
    <link href="https://qoosuperman.github.io/article/2023-06-12-Swiss_Travel_Notes/"/>
    <id>https://qoosuperman.github.io/article/2023-06-12-Swiss_Travel_Notes/</id>
    <published>2023-06-12T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.534Z</updated>
    
    <content type="html"><![CDATA[<h2>Outline</h2><ul><li><a href="#%E8%A1%8C%E7%A8%8B">行程</a></li><li><a href="#%E4%BD%8F%E5%AE%BF%E8%A9%95%E5%83%B9">住宿評價</a></li><li><a href="#%E9%A3%9F%E7%89%A9">食物</a></li><li><a href="#%E4%BA%A4%E9%80%9A">交通</a></li><li><a href="#%E9%87%8D%E8%B3%AA%E4%B8%8D%E9%87%8D%E9%87%8F">重質不重量</a></li><li><a href="#%E5%90%84%E7%A8%AE%E8%B2%BC%E5%BF%83%E4%B9%8B%E8%99%95">各種貼心之處</a></li><li><a href="#%E5%93%81%E7%89%8C">品牌</a></li></ul><h2>行程</h2><p>Day1: Geneva --&gt; 湖邊閒晃 --&gt; 火車 --&gt; Zurich --&gt; 散步 --&gt; 入住 Hotel Limmathof</p><p>Day2: Zurich --&gt; 散步去 Lindenhof --&gt; 搭火車去 Üetliberg 俯瞰 Zurich --&gt; 搭火車 --&gt; Chur -&gt; 散步去 Haldenhüttli 看風景 --&gt; 入住 Hotel Post</p><p>Day3: Chur --&gt; 冰河列車 --&gt; Zermatt --&gt; 入住 Apartment Alpharmonie</p><p>Day4: Zermatt --&gt; 搭火車到 Sunnegga --&gt; 五湖健行 --&gt; 搭 Sunnegga 回 Zermatt</p><p>Day5: Zermatt --&gt; 搭火車到 Gornegrat --&gt; 從沒雪的車站開始健行回 Zermatt</p><p>Day6: Zermatt --&gt; 搭火車到 Glacier Paradise --&gt; 回車站附近吃漢堡</p><p>Day7: Zermatt --&gt; 火車 --&gt; Interlaken --&gt; Harder Kulm --&gt; 慢跑 --&gt; 入住 Dependance West</p><p>Day8: Interlaken OST --&gt; First 玩卡丁車 / 滑板車 --&gt; 健行到 Bachalpsee --&gt; 回 Interlaken</p><p>Day9: Interlaken OST --&gt; 纜車 --&gt; 雪朗峰 --&gt; 纜車下山 --&gt; Stechelberg 散步到 lauterbrunun --&gt; 回 Interlaken</p><p>Day10: 飛行傘 --&gt; Geneva</p><p>其中我最推薦的前三會是 1.五湖健行 2.First設施 3.飛行傘</p><h2>住宿評價</h2><p>Zurcih 住宿: Hotel Limmathof，離蘇黎世火車站很近，但房間偏舊，不過很乾淨也很安靜很可以接受</p><p>Chur 住宿: Hotel Post，早餐很好吃，位置在 Chur 的主要大街上，很喜歡住的房間屋頂有天窗，也很貼心的有附上給外籍遊客的插座，比上面那間更為乾淨許多，非常喜歡</p><p>Zermatt 住宿: Apartment Alpharmonie，交通很不方便，不方便到要回去的路有被列在其中一條步道裡面，從車站走回家大概要 25 min，如果有等到公車，走回去只需要 10 min，雖然交通不便但是 View 極好，大部分交通方便的住宿都無法看到馬特洪峰，但我們住在比較山腰，客廳跟房間都可以超清楚看到馬特洪峰</p><p>Interlaken 住宿: Dependance West，這趟住到最高級的住宿，可以租借它們的 spa 房，有超大的 spa 浴缸還有烤箱，在使用的同時還可以用電視看 youtbue / netflix，超享受，但交通也不到很方便，不過如果有公車的話可以直達</p><p>Geneva 住宿: ibis 機場酒店，很小很可愛，也很有設計感，對於要趕凌晨班機的我們來說很方便</p><p>從策馬特住宿看出去的景色:<br><img src="https://scontent.ftpe8-1.fna.fbcdn.net/v/t39.30808-6/349319457_815015366627339_8059589611053303486_n.jpg?_nc_cat=105&amp;ccb=1-7&amp;_nc_sid=8bfeb9&amp;_nc_ohc=ATV99IHUad0AX_anghF&amp;_nc_ht=scontent.ftpe8-1.fna&amp;oh=00_AfDKLzGkkS5AFWreTbMZ9P0mk58ZRIINO45oEY8pV1yGsw&amp;oe=648BF1C2" alt="從策馬特住宿看出去的景色"></p><h2>食物</h2><p>那裡的各種超市 Coop / Migros / DiDL 在那裡是我們的救星，超市的東西比餐廳 / 便利商店賣的飲料跟食物很多都便宜一半左右，其中尤其 DiDL 價格更低（但數量比較少），有一種量販店的感覺</p><p>我們會買蔬菜 / 牛排 / 香腸 / 蛋 / 蘑菇回去料理，其中以蘑菇最為推薦，其他蔬菜沒有台灣市場的甜，生吃的話主要就是藍莓 / 生火腿 / 起士，其中藍莓真的是最棒，又甜又便宜</p><h2>交通</h2><p>雖然瑞士的火車真的是貴到爆，但是火車的 app 極度好用，可以像是 google map 一樣跟你說如果要到某個地方，途中要去哪裡轉公車 or 纜車，儘管不能買票他還是會幫你算好，而且瑞士的驗票頻率極高，這個 app 也可以顯示 qr code 很方便驗票</p><p>公車方面，Geneva / Interlaken / Zermatt 如果有住宿的話公車都是免費可以搭的，多加利用可以省下很多錢跟時間（比方說在策馬特如果要搭計程車到一個公車可以到的地方，至少就會多花個 500 塊吧）</p><h2>重質不重量</h2><p>整趟玩下來，瑞士給我的感覺就是充滿了重質不重量的感覺，另一方面也可以說好像時間更貴了</p><p>如果想要買汽水，你可以花 100 塊去超商買，你也可以走 10 分鐘花 35 塊去超市買到一模一樣的汽水，在台灣我相信價差是不可能到這麼多</p><p>另一個重質的觀察是，當我在 First 排遊樂設施的時候，發現有個滑索的設施工作人員不斷在做調整，而且可能 10:30 am 才調整完，玩到中午 12 點就不讓人玩了，我猜測是下午天氣好像不太好（但當時也沒有下雨），有安全上的疑慮，我不禁在想如果是台灣的話業者一定是能賺到越多人的錢越好吧，怎麼可能因為一點小小雨就不賺</p><p>在 First 玩滑板車<br><img src="https://scontent.ftpe7-4.fna.fbcdn.net/v/t39.30808-6/350799345_238605742133553_7553344209068628742_n.jpg?_nc_cat=107&amp;cb=99be929b-59f725be&amp;ccb=1-7&amp;_nc_sid=8bfeb9&amp;_nc_ohc=Wc-QRy_STwIAX_4QUGM&amp;_nc_ht=scontent.ftpe7-4.fna&amp;oh=00_AfCv59gwlwMAui4gvVxDFZpUsOYBqkGb_GURbbLZDBoE5g&amp;oe=64A2E343" alt=""></p><h2>各種貼心之處</h2><p>儘管這裡的物價貴，但也讓遊客不會白白當盤子，比方說在著名的景點，像是少女峰 / First / Gornegrat 等等都有裝 WebCam，可以透過網路看看現在上面的景色好不好，你真的想上去再上去</p><p>另外這裡的健行景點都有幫每個步道做分級，還有大概多久你可以走完，告示牌貼在各種顯眼之處，就連步道的沿途也都有官方標示的印記，讓你知道你沒有走錯路，反觀台灣都要靠山友幫忙做標示，不知道有沒有機會跟進</p><p>瑞士步道上的標記：<br><img src="https://img.freepik.com/premium-photo/swiss-trail-mark-hiking-switzerland-back-matterhorn-peak-also-called-cervino_735136-2.jpg?w=1800" alt=""></p><h2>品牌</h2><p>最後這個點可能是我有點太 picky 了</p><p>一到瑞士機場內部，通道上的廣告就都是瑞士名錶品牌，反觀台灣的機場內的廣告卻是各種地區風景（但大多也沒有瑞士的好看），甚至還有佛教的廣告，就覺得不勝唏噓，台灣美其名是很多隱形冠軍，但講白一點就是沒有真的夠大的品牌（畢竟最大的公司都是代工，難道要叫遊客買一片晶圓回家當鏡子用）</p><h2>心得</h2><p>這是第一次踏上歐洲的土地，所見所聞都讓我非常受到衝擊，也衍伸了很多想法（是不是年紀大了 QQ）</p><p>現在國內旅遊價格越來越不合理，也越來越了無新意，所以與其常常在做些不太會有深刻印象的國內旅遊，覺得一次把錢花在會一生印象深刻的國外旅遊反而是比較好的選擇，不管是這次去瑞士還是三年多前去秘魯，我都覺得都是非常棒的人生經驗！</p>]]></content>
    
    
    <summary type="html">Swiss Travel Notes</summary>
    
    
    
    
    <category term="Life" scheme="https://qoosuperman.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Steps to Upgrade Rails</title>
    <link href="https://qoosuperman.github.io/article/2023-03-27-Steps_to_Upgrade_Rails/"/>
    <id>https://qoosuperman.github.io/article/2023-03-27-Steps_to_Upgrade_Rails/</id>
    <published>2023-03-27T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子升級了公司專案的 Rails 版本，寫個文章記錄一下</p><p>升級 Rails 的步驟可以參考社群給的 <a href="https://guides.rubyonrails.org/upgrading_ruby_on_rails.html" target="_blank" rel="noopener">Guide</a></p><p>升級前最低要求：test coverage 要完整，否則根本不知道上線之後哪裡會爆掉，而且可能很多小細節是 QA 測不出來的</p><h2>Step1: Update Rails version</h2><p>因為相伴隨有很多 dependencies 所以無法單純用 <code>bundle update rails</code>，要找到相對應所有會卡 dependency 的 gem 來一起做升級</p><p>ex.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle update rails actionpack actionview activemodel activerecord activesupport railties sprockets thor bundler-audit</span><br></pre></td></tr></table></figure><h2>Step2: Update Rails version</h2><p>升級完之後，可以跑一個 rake 幫忙產生需要的檔案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rails app:update</span><br></pre></td></tr></table></figure><p>他主要會產生 <code>config/initializers/new_framework_defaults_X.Y.rb</code> 這樣的一個檔案，並把一些你會需要自己設定的參數放在檔案中，這時候就要了解每個參數的意義再去設定成你要的值</p><p>我們的作法是最後拔除這個檔案，把需要 overwrite 的設定放回 <code>config/application.rb</code> 或者 <code>config/environments/&lt;environment&gt;.rb</code> 裡面，如果是符合新版本的預設設定就不特別寫</p><p>另外這個 rake 也可能不只產生這個檔案，像是我這次升級 Rails6.1，ActiveStorage 就有一個相關的 migration 需要執行，他也會自動生成 migration 檔案</p><h2>Step3: Fix tests</h2><p>開始修 spec 通常才是最花時間的地方，以下列出一些在這次升級時遇到的一些問題</p><h3>Issues</h3><ol><li>一些 gem 也需要跟著升級，但 dependency 沒有更新到，包括<a href="https://github.com/CanCanCommunity/cancancan/issues/666" target="_blank" rel="noopener">cancancan 需要升級</a>, <a href="https://github.com/paper-trail-gem/paper_trail#1a-compatibility" target="_blank" rel="noopener">paper trail 需要升級</a></li><li><a href="https://github.com/dejan/rails_panel/pull/177#issuecomment-797378347" target="_blank" rel="noopener">meta request 這個 gem 造成 stack level too deep</a>，因為這個 gem 提供的功能目前團隊內沒有人使用因此直接拔除</li><li>有個 action text 相關的 controller spec 升級後過不了，結果改成 request spec 就過了，可能是跟 <a href="https://github.com/rails/rails/pull/40222" target="_blank" rel="noopener">這個</a> 有關</li><li>Rails6.1 在 error message 處理的改動比較多，所以需要修改滿多地方的，詳細可看 <a href="https://code.lulalala.com/2020/0531-1013.html" target="_blank" rel="noopener">這篇</a></li><li>隨著 Multi Tenant 架構的調整</li><li>搭配 Apartment gem 的使用，造成偵測到 rails_admin 的 source code 有 sql injection，需要用 patch 去改 rails_admin 的 source code</li></ol>]]></content>
    
    
    <summary type="html">Steps to Upgrade Rails</summary>
    
    
    
    
    <category term="Rails" scheme="https://qoosuperman.github.io/tags/Rails/"/>
    
    <category term="Ruby" scheme="https://qoosuperman.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Synopsis of Rebuilding Rails</title>
    <link href="https://qoosuperman.github.io/article/2023-01-30-Synopsis_of_rebuilding_rails/"/>
    <id>https://qoosuperman.github.io/article/2023-01-30-Synopsis_of_rebuilding_rails/</id>
    <published>2023-02-13T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>看了 Rebuilding Rails 這本書，內容沒有想像中豐富，但裡面會教你從頭做一個非常陽春版本的 Rails 出來（書裡面叫他 Rulers），從頭寫一個 gem 出來相較比較少人在講，所以覺得滿實用的，只是因為之前自己有稍微研究過所以滿多已經知道的內容，這篇就只稍微紀錄一下小知識跟延伸閱讀</p><h3>LOAD_PATH</h3><p>在 gem 裡面可以多善用 <code>$LOAD_PATH</code> 這個全域變數，比方說在 test helper 裡面我們這樣寫：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$LOAD_PATH.unshift(File.expand_path(<span class="string">'../../lib'</span>, __FILE_<span class="number">_</span>))</span><br><span class="line"><span class="comment"># 如果這個檔案是 /Users/anthonychao/Desktop/test.rb</span></span><br><span class="line"><span class="comment"># 結果會是 /Users/anthonychao/lib</span></span><br></pre></td></tr></table></figure><p>把當下這個 gem 的 lib 資料夾放在 load path 最前面，這樣可以保證 local 的 code 可以最先被讀到，如果你已經安裝了另一個版本的 gem，這樣做還是可以保證 local 的 code 先被讀到</p><h3>gem 會按照 gemspec 裡面的 files 設定去 build 檔案</h3><p>gemspec 裡面 files 的 default 設定是會去看 git 裡面有哪些檔案去 build</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rulers.gemspec</span></span><br><span class="line">  spec.files         = Dir.chdir(File.expand_path(<span class="string">'..'</span>, __FILE_<span class="number">_</span>)) <span class="keyword">do</span></span><br><span class="line">    <span class="string">`git ls-files -z`</span>.split(<span class="string">"\x0"</span>).reject &#123; <span class="params">|f|</span> f.match(<span class="regexp">%r&#123;^(test|spec|features)/&#125;</span>) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也因此最好把 build 出來的 binary 放到 gitignore 裡面，否則如果不小心放到 git 裡面會一直出現錯誤</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitignore</span></span><br><span class="line">rulers-*.gem</span><br></pre></td></tr></table></figure><h3>可以在 Gemfile 指定 path</h3><p>如果要開發 gem，可以在 Gemfile 指定 path，但這麼做之後都需要搭配 bundle exec 來使用，否則可能會找不到 gem 或者用到舊版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem &quot;rulers&quot;, path: &apos;../rulers&apos;</span><br></pre></td></tr></table></figure><h3>Unix 系統的指令小技巧</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec rerun -- rackup -p <span class="number">3001</span></span><br></pre></td></tr></table></figure><p>其中 <code>--</code> 這個是 UNIX 的一個小技巧，代表 – 之後的參數前面的指令都不能用，如果沒有這個 <code>--</code> 則 -p 這個參數會被 rerun 拿去使用</p><h3>使用 method_missing 的時候也要搭配 respond_to_missing? 使用</h3><p>其實如果只去改寫 method_missing 的話還是可以正常操作的，但某些行為上會比較無法預期</p><p>像是下面這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StereoPlayer</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(method, *args, &amp;block)</span></span></span><br><span class="line">    <span class="keyword">if</span> method.to_s =~ <span class="regexp">/play_(\w+)/</span></span><br><span class="line">      puts <span class="string">"Here's <span class="subst">#&#123;$1&#125;</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p = StereoPlayer.new</span><br><span class="line"><span class="comment"># ok:</span></span><br><span class="line">p.play_some_Beethoven <span class="comment"># =&gt; "Here's some_Beethoven"</span></span><br><span class="line"><span class="comment"># not very polite:</span></span><br><span class="line">p.respond_to? <span class="symbol">:play_some_Beethoven</span> <span class="comment"># =&gt; false</span></span><br></pre></td></tr></table></figure><p>在 Ruby1.9.2 之後提供了 respond_to_missing? 這個 method，可以讓這些從 method_missing 產生的 method 更像一般的 method</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StereoPlayer</span></span></span><br><span class="line">  <span class="comment"># def method_missing ...</span></span><br><span class="line">  <span class="comment">#   ...</span></span><br><span class="line">  <span class="comment"># end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">respond_to_missing?</span><span class="params">(method, *)</span></span></span><br><span class="line">    method =~ <span class="regexp">/play_(\w+)/</span> <span class="params">||</span> <span class="keyword">super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p = StereoPlayer.new</span><br><span class="line">p.play_some_Beethoven <span class="comment"># =&gt; "Here's some_Beethoven"</span></span><br><span class="line">p.respond_to? <span class="symbol">:play_some_Beethoven</span> <span class="comment"># =&gt; true</span></span><br><span class="line">m = p.method(<span class="symbol">:play_some_Beethoven</span>) <span class="comment"># =&gt; #&lt;Method: StereoPlayer#play_some_Beethoven&gt;</span></span><br><span class="line"><span class="comment"># m acts like any other method:</span></span><br><span class="line">m.call <span class="comment"># =&gt; "Here's some_Beethoven"</span></span><br><span class="line">m == p.method(<span class="symbol">:play_some_Beethoven</span>) <span class="comment"># =&gt; true</span></span><br><span class="line">m.name <span class="comment"># =&gt; :play_some_Beethoven</span></span><br></pre></td></tr></table></figure><p>可以配合這篇 <a href="http://blog.marc-andre.ca/2010/11/15/methodmissing-politely/" target="_blank" rel="noopener">文章</a> 一起服用</p><h3>啟動 irb 的時候加上 -r 參數就會自動 require</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle exec irb -r rulers</span><br></pre></td></tr></table></figure><h3>Rails Routing</h3><p>現在要仿效 Rails Router 的方式來做，概念上像是 <a href="https://medium.com/rubyinside/a-deep-dive-into-routing-and-controller-dispatch-in-rails-8bf58c2cf3b5" target="_blank" rel="noopener">這篇文章</a> 裡面這張圖</p><p><img src="https://i.imgur.com/iJWa1Qr.png" alt=""></p><p>在簡單的實作中不會有後面 Journey 那一段，request 進來之後會先給 middleware 處理，接著轉交給我們的 app 特定的 controller / action 處理之後傳回 response</p><p>如果要大概知道 Journey 運作的概念可以看這個 <a href="https://www.youtube.com/watch?v=lEC-QoZeBkM&amp;t=549s" target="_blank" rel="noopener">影片</a>，我下面擷取出一些我認為比較重要的概念</p><p>實際上我們的每一個 controller + action 都是 rack app 的端點，所以其實我們可以這樣做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  root &#123; [<span class="number">200</span>, &#123;&#125;, [<span class="string">'this works!'</span>]] &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而在 Rails 的眾多 middleware 中，最後一個就是 routes，當他匹配到對應的 controller + action，就會發包出去處理</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; rails middleware</span><br><span class="line">...</span><br><span class="line">run MyApp::Application.routes <span class="comment"># 最後一層 middleware</span></span><br></pre></td></tr></table></figure><p>Journey 的 routing 並不是簡單的很多 regular expression 一個一個對照，畢竟這樣會造成時間複雜度 O(n) 的成長</p><p>Journey 做的事情跟郵局有點像，郵局依靠地址一步一步縮小範圍最後指定到某個信箱，Journey 把 url 變成一段一段的 token (tokenize) 之後，一步一步去縮小範圍找到最後的端點，更詳細的介紹推薦看影片~</p>]]></content>
    
    
    <summary type="html">Synopsis of Rebuilding Rails</summary>
    
    
    
    
    <category term="Rails" scheme="https://qoosuperman.github.io/tags/Rails/"/>
    
    <category term="Ruby" scheme="https://qoosuperman.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Synopsis of Nothing is Something</title>
    <link href="https://qoosuperman.github.io/article/2023-01-30-Synopsis_of_Nothing_is_Something/"/>
    <id>https://qoosuperman.github.io/article/2023-01-30-Synopsis_of_Nothing_is_Something/</id>
    <published>2023-01-30T22:26:24.000Z</published>
    <updated>2025-05-04T14:24:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>看了 Sandi Metz 在 RailsConf 2015 的 <a href="https://www.youtube.com/watch?v=OMPfEXIlTVE&amp;t=1808s" target="_blank" rel="noopener">演講</a>，覺得很受啟發，因此想要將這個演講的內容做個摘要紀錄下來，以下代稱 Sandi Metz 為講者</p><h2>Outline</h2><ul><li><a href="#boolean-syntax-in-ruby">Boolean Syntax in Ruby</a></li><li><a href="#send-message-instead-of-conditions">Send Message Instead of Conditions</a></li><li><a href="#null-object">Null Object</a></li><li><a href="#refactor-a-real-example">Refactor a Real Example</a></li><li><a href="#summary">Summary</a></li><li><a href="#references">References</a></li></ul><h2>Boolean Syntax in Ruby</h2><p>講者一開始寫過 Smalltalk 這個接近純 OO 的語言，而這個語言後來啟發了更多像是 Python / Ruby 等語言，在接觸 Ruby 的時候有的部分他覺得很不習慣</p><p>寫 Ruby 要知道 send message 才是正常的寫法，而使用 <code>.</code> 則可以說是 Ruby 提供的語法糖</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.to_s</span><br><span class="line"><span class="comment"># 會等於</span></span><br><span class="line"><span class="number">1</span>.send(<span class="symbol">:to_s</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 會等於</span></span><br><span class="line"><span class="number">1</span>.send(<span class="symbol">:+</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面的東西不令講者感到意外，令他意外的是一些 boolean 的特殊語法</p><p>Smalltalk 的關鍵字有幾種：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true false nil self super thisContext</span><br></pre></td></tr></table></figure><p>但是 Ruby 則有很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if alias and BEGIN def defined? .....</span><br></pre></td></tr></table></figure><p>其中他認為最特別的是 if</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (truthy)</span><br><span class="line">  <span class="comment"># code to eval when 'true'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># code to eval when 'false'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其實 OO 裡面是討厭 type check 的，應該改用 OO 的方式來做，也就是改用 send message 的方式來做</p><h2>Send Message Instead of Conditions</h2><p>那我們可以如何用 OO 的方式做到 if else 呢？ 我們可以 monkey patch</p><p>true 跟 false 的 class 分別是 TrueClass 跟 FalseClass</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrueClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">if_true</span></span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">if_false</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FalseClass</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">if_true</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">if_false</span></span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的改寫讓我們可以達到這樣的效果</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> == <span class="number">1</span>).if_true &#123; puts <span class="string">'evaluated block'</span> &#125;</span><br><span class="line">&gt; <span class="string">'evaluated block'</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> == <span class="number">1</span>).if_false &#123; puts <span class="string">'evaluated block'</span> &#125;</span><br><span class="line"><span class="comment"># block ignored</span></span><br></pre></td></tr></table></figure><p>所以其實我們根本不需要 if</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">  puts <span class="string">'is true'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">'is false'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 改寫</span></span><br><span class="line">(<span class="number">1</span> == <span class="number">1</span>).</span><br><span class="line">  if_true &#123; puts <span class="string">'is true'</span> &#125;.</span><br><span class="line">  if_false &#123; puts <span class="string">'is false'</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>I don’t want to change Ruby<br>I want to change you</p></blockquote><p>講者強調他並沒有想要大家改成這樣寫，但是他希望大家多想想如果沒有 if 的話該怎麼做，因為他很討厭 conditions</p><h2>Null Object</h2><p>在平常時，我們可能很容易因為下面的情境遇到 NoMethodError</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Animal.find(<span class="string">'pig'</span>)</span><br><span class="line">&gt; <span class="comment"># object</span></span><br><span class="line">Animal.find(<span class="string">''</span>)</span><br><span class="line">&gt; <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">ids = [<span class="string">'pig'</span>, <span class="string">''</span>, <span class="string">'sheep'</span>]</span><br><span class="line">animals = ids.map &#123; <span class="params">|id|</span> Animal.find(id) &#125;</span><br><span class="line"><span class="comment"># 第二個是 nil</span></span><br><span class="line">animals.each &#123; <span class="params">|animal|</span> puts animal.name &#125;</span><br><span class="line">&gt; NoMethodError</span><br></pre></td></tr></table></figure><p>為了要修正上面的錯誤，我們常常做一些事情像是下面這樣</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">animals.each &#123; <span class="params">|animal|</span></span><br><span class="line">  puts animal.<span class="literal">nil</span>? ? <span class="string">'no animal'</span> : animal.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面可以，但有點醜</span></span><br><span class="line">animals.each &#123; <span class="params">|animal|</span></span><br><span class="line">  puts animal &amp;&amp; animal.name</span><br><span class="line">&#125;</span><br><span class="line">animals.each &#123; <span class="params">|animal|</span></span><br><span class="line">  puts animal.try(<span class="symbol">:name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我們仔細看看裡面的東西</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">puts animal.try(<span class="symbol">:name</span>)</span><br><span class="line">puts animal.<span class="literal">nil</span>? ? <span class="string">''</span> : animal.name</span><br><span class="line">puts animal == <span class="literal">nil</span> ? <span class="string">''</span> : animal.name</span><br><span class="line">puts animal.is_a?(NilClass) ? <span class="string">''</span> : animal.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> animal.is_a?(NilClass)</span><br><span class="line">  puts <span class="string">''</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts animal.name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這不就是講者最討厭的 conditions 嗎 XD</p><p>而講者討厭的原因就是因為這些 condition 會不斷地在 code 裡面繁殖</p><p>他想要的就是單純送一個 message (message centric) 就不用在裡面使用 if 或者三元判斷式</p><p>所以先改成這樣做：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingAnimal</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span></span><br><span class="line">    <span class="string">'no animal'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">animals = ids.map &#123; <span class="params">|id|</span> Animal.find(id) <span class="params">||</span> MissingAnimal.new &#125;</span><br><span class="line">animals.each &#123; <span class="params">|animal|</span> puts animal.name &#125;</span><br><span class="line"><span class="comment"># 雖然解決了問題，但在這裡用 MissingAnimal 造成了 dependency(多知道一個 object 的功能)</span></span><br></pre></td></tr></table></figure><p>這就是 Null Object Pattern</p><p>Null Object Pattern 的精神簡短來說就是 Active Nothing(可互動的 nothing)</p><p>為了進一步解決上述 dependency 的問題，需要再包一層物件上去</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuatenteedAnimal</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">find</span><span class="params">(id)</span></span></span><br><span class="line">    Animal.find(id) <span class="params">||</span> MissingAnimal.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">animals = ids.map &#123; <span class="params">|id|</span> GuatenteedAnimal.find(id) &#125;</span><br><span class="line">animals.each &#123; <span class="params">|animal|</span> puts animal.name &#125;</span><br></pre></td></tr></table></figure><p>講者為這個例子做了一個總結</p><blockquote><p>Sometimes nil is nothing<br>But if you send it a message, nil is Something<br>If you’re talking to nil, then it’s something, stop checking nil</p></blockquote><p>請大家開始相信 believe in nothing，就像 0 這個數字對我們來說的意義一樣</p><p>在有 0 這個概念以前，我們有一些事情是做不到的，有了 0 這個概念之後就變得很方便</p><p>但講者過去一段時間了解到 null object pattern 其實是一個簡單概念的其中一個小例子，接下來會再舉一個例子</p><h2>Refactor a Real Example</h2><p>在這個例子中，一開始的功能是要把歌詞印出來</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">phrase</span><span class="params">(number)</span></span></span><br><span class="line">    data.last(number).join(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(number)</span></span></span><br><span class="line">    <span class="string">"This is <span class="subst">#&#123;phrase(number)&#125;</span>.\n"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">recite</span></span></span><br><span class="line">    (<span class="number">1</span>..data.length).map &#123; <span class="params">|i|</span> lin(i)&#125;.join(<span class="string">"\n"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    [</span><br><span class="line">      <span class="string">'This is the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the cat that chased the rat,'</span></span><br><span class="line">      <span class="string">'That ate the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the dog that worried the cat,'</span></span><br><span class="line">      <span class="string">'That chased the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">    ]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這時候新需求來了： New feature =&gt; RandomHouse</p><p>這個需求的具體內容是需要歌詞可以亂序排列，這時候繼承是一個很有吸引力的選擇，只要改一點 code ，下面這樣做就完成了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomHouse</span> &lt; House</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    @data <span class="params">||</span>= <span class="keyword">super</span>.shuffle</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">RandomHouse.new.prase(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>這時候又有新需求來了： New feature =&gt; EchoHouse</p><p>這個需求的具體內容是需要歌詞的同一個句子要重複兩次，首先改一下 House 裡面的內容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">phrase</span><span class="params">(number)</span></span></span><br><span class="line">    data.last(number).join(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 改成</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">phrase</span><span class="params">(number)</span></span></span><br><span class="line">    parts(number).join(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parts</span><span class="params">(number)</span></span></span><br><span class="line">    data.last(number)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這時候繼承還是一個很有吸引力的選擇</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoHouse</span> &lt; House</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parts</span><span class="params">(number)</span></span></span><br><span class="line">    <span class="keyword">super</span>.zip(<span class="keyword">super</span>).flattern</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>現在的繼承狀況是這樣<br><img src="https://i.imgur.com/TWUouOu.png" alt=""></p><p>就在這時候又有新需求來了： New feature =&gt; RandomEchoHouse</p><p>這時候就慘了</p><p>講者請大家試試看，請不要覺得繼續繼承或者拆出 module 共用可以解決你的問題</p><p>比方說繼續使用繼承也會很糟，因為跟 Echo House 的 code 重複了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomEchoHouse</span> &lt; RandomHouse</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">parts</span><span class="params">(number)</span></span></span><br><span class="line">  <span class="keyword">super</span>.zip(<span class="keyword">super</span>).flatten</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這時候更多人的選擇不是像上面一樣只重複部分的 code，而是重複所有的 code</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomEchoHouse</span> &lt; House</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    @data <span class="params">||</span>= <span class="keyword">super</span>.shuffle</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parts</span><span class="params">(number)</span></span></span><br><span class="line">    <span class="keyword">super</span>.zip(<span class="keyword">super</span>).flatten</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>為什麼這時候會遇到這個困難呢？</p><p>用圖片來說明比較清楚：</p><p><img src="https://i.imgur.com/NPQSIBZ.png" alt=""></p><p>我們可能以為 RandomHouse 只有橘色框框的部分，但其實真正的範圍比我們想像的範圍大，因為綠色部分是繼承而來的</p><p><img src="https://i.imgur.com/T9a2hmg.png" alt=""></p><p>當我們想要兩者的功能但只繼承其中一邊的話是不可能的</p><p>講者為這一段說明留下一句註解：</p><blockquote><p>Inheritance is for specialization, is not for sharing code</p></blockquote><p><strong>那到底該怎麼解決這個問題呢？</strong></p><p>這時候要問問自己一個問題 is Random House a House? ，如果是的話才適用於使用繼承的情境</p><p>不要因為命名是 House 就被騙了，應該要觀察行為來決定</p><p>我們回頭看看 Random House 的行為，我們要觀察他們哪裡不一樣最快的方式就是把他們變的越接近越容易看出來</p><blockquote><p>Reveal how things differ by making them more alike</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    [</span><br><span class="line">      <span class="string">'This is the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the cat that chased the rat,'</span></span><br><span class="line">      <span class="string">'That ate the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the dog that worried the cat,'</span></span><br><span class="line">      <span class="string">'That chased the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">    ]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomHouse</span> &lt; House</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    @data <span class="params">||</span>= <span class="keyword">super</span>.shuffle</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 改成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  DATA =</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'This is the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the cat that chased the rat,'</span></span><br><span class="line">      <span class="string">'That ate the malt that lay in the house that Jack built.'</span></span><br><span class="line">      <span class="string">'This is the dog that worried the cat,'</span></span><br><span class="line">      <span class="string">'That chased the rat that ate the malt,'</span></span><br><span class="line">      <span class="string">'That lay in the house that Jack built.'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    @data <span class="params">||</span>= DATA</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomHouse</span> &lt; House</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">data</span></span></span><br><span class="line">    @data <span class="params">||</span>= DATA.shuffle</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用表格來做思考，然後什麼改變了就給他一個名字</p><table><thead><tr><th>class</th><th>data</th><th>???</th></tr></thead><tbody><tr><td>House</td><td>DATA</td><td></td></tr><tr><td>RandomHouse</td><td>DATA</td><td>shuffle</td></tr></tbody></table><p>這裡的 ??? 應該填入什麼呢？往他上一層抽象來想的話，比較準確的應該是 order</p><table><thead><tr><th>class</th><th>data</th><th>order!</th></tr></thead><tbody><tr><td>House</td><td>DATA</td><td></td></tr><tr><td>RandomHouse</td><td>DATA</td><td>shuffle</td></tr></tbody></table><p>這時候再重新問一次上面的問題：</p><p>Is Order a House?</p><p>明顯不是，那 Order 是什麼呢？他其實比較接近一個角色(role)，可以說是功能型球員，我們根據這樣的概念來改寫：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultOrder</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(data)</span></span></span><br><span class="line">    data</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomOrder</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">(data)</span></span></span><br><span class="line">    data.shuffle</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們現在需要的是把排序的相依從 House 裡面拿出來</p><p>首先改寫一下 House</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  DATA = [...]</span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:data</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @data = Data</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然後把對 order 的相依性放進去</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  DATA = [...]</span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:data</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(orderer = DefaultOrder.new)</span></span></span><br><span class="line">    @data = orderer.order(DATA)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這裡的概念就是把不同的東西抽出來，做成 pluggable behavior 的樣子</p><p>更精簡來說：</p><blockquote><p>Inject an object to play the role of the thing that varies</p></blockquote><p>之後使用一樣的方式去改寫 EchoHouse</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(<span class="symbol">orderer:</span> DefaultOrder.new, <span class="symbol">formatter:</span> DefaultFormatter.new)</span></span></span><br><span class="line">    @formatter = formatter</span><br><span class="line">    @data = orderer.order(DATA)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parts</span><span class="params">(number)</span></span></span><br><span class="line">    formatter.format(data.last(number))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultFormatter</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(parts)</span></span></span><br><span class="line">    parts</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoFormatter</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(parts)</span></span></span><br><span class="line">    parts.zip(parts).flatten</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts House.new(<span class="symbol">formatter:</span> EchoFormatter.new).line(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>這樣一來就解決了這個新需求的問題</p><p>把上面做的事情一樣一樣列出來的話可以拆成四個步驟：</p><ol><li>Isolate the thing that vary</li><li>Name the concept</li><li>Define the Role</li><li>Inject the player</li></ol><p>而這樣的方式使用到大家在討論 refactor 的兩個概念：composition + dependency injection</p><h2>Summary</h2><p>看完這個 talk 真的受益良多，寫 code 滿容易卡在苦無思考方向，也許這個 talk 是一個很好的思考起點</p><p>另外之前碰到一些感覺需要 refactor 的 code 但不知道從何開始，有些情況應該是照著這樣的邏輯去解掉的</p><h2>References</h2><p><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE&amp;t=1808s" target="_blank" rel="noopener">RailsConf video</a></p>]]></content>
    
    
    <summary type="html">Synopsis of Nothing is Something</summary>
    
    
    
    
    <category term="SQL" scheme="https://qoosuperman.github.io/tags/SQL/"/>
    
  </entry>
  
</feed>
